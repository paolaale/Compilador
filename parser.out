Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program
Rule 2     program_classes -> classes
Rule 3     program_classes -> empty
Rule 4     program_body -> program_body_vars program_body_funct
Rule 5     program_body_vars -> dec_vars
Rule 6     program_body_vars -> empty
Rule 7     program_body_funct -> functions
Rule 8     program_body_funct -> empty
Rule 9     dec_vars -> VAR dec_vars_aux
Rule 10    dec_vars_aux -> dec_vars_simple
Rule 11    dec_vars_aux -> dec_vars_complex
Rule 12    dec_vars_simple -> simple_type vars_simple_type SEMICOLON
Rule 13    dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux
Rule 14    simple_type -> INT
Rule 15    simple_type -> FLOAT
Rule 16    simple_type -> CHAR
Rule 17    vars_simple_type -> ID add_variable
Rule 18    vars_simple_type -> ID add_variable COMMA vars_simple_type
Rule 19    vars_simple_type -> ID vars_simple_type_aux
Rule 20    vars_simple_type -> ID vars_simple_type_aux COMMA vars_simple_type
Rule 21    vars_simple_type_aux -> LBRACKET CTEI RBRACKET add_array_variable
Rule 22    vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable
Rule 23    dec_vars_complex -> OBJECT vars_complex_type SEMICOLON
Rule 24    dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux
Rule 25    vars_complex_type -> ID add_variable
Rule 26    vars_complex_type -> ID add_variable COMMA vars_complex_type
Rule 27    classes -> CLASS OBJECT classes_aux
Rule 28    classes -> CLASS OBJECT classes_aux classes
Rule 29    classes_aux -> add_class LBRACE dec_vars functions RBRACE
Rule 30    classes_aux -> add_class LBRACE functions RBRACE
Rule 31    classes_aux -> INHERITS OBJECT add_inherit_class LBRACE dec_vars functions RBRACE
Rule 32    classes_aux -> INHERITS OBJECT add_inherit_class LBRACE functions RBRACE
Rule 33    functions -> FUNCT functions_aux
Rule 34    functions -> FUNCT functions_aux functions
Rule 35    functions_aux -> VOID ID add_function LPAREN params RPAREN insert_number_params body
Rule 36    functions_aux -> VOID ID add_function LPAREN RPAREN body
Rule 37    functions_aux -> simple_type ID add_function LPAREN RPAREN body
Rule 38    functions_aux -> simple_type ID add_function LPAREN params RPAREN insert_number_params body
Rule 39    params -> simple_type ID add_param
Rule 40    params -> simple_type ID add_param COMMA params
Rule 41    body -> LBRACE start_function dec_vars statutes_aux RBRACE end_function
Rule 42    body -> LBRACE start_function statutes_aux RBRACE end_function
Rule 43    body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
Rule 44    body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
Rule 45    body -> LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function
Rule 46    statutes -> assignation SEMICOLON
Rule 47    statutes -> CALL call SEMICOLON
Rule 48    statutes -> read
Rule 49    statutes -> write
Rule 50    statutes -> condition
Rule 51    statutes -> while
Rule 52    statutes -> for
Rule 53    statutes_aux -> statutes
Rule 54    statutes_aux -> statutes statutes_aux
Rule 55    assignation -> ID push_var EQUAL push_op exp pop_op_assign
Rule 56    assignation -> ID var_aux EQUAL push_op exp pop_op_assign
Rule 57    assignation -> ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
Rule 58    var_aux -> POINT ID push_obj_var
Rule 59    var_aux -> POINT ID var_aux_2
Rule 60    var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3
Rule 61    var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix
Rule 62    var_aux_3 -> end_array
Rule 63    call -> ID exist_function LPAREN era_function RPAREN gosub_function
Rule 64    call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
Rule 65    call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
Rule 66    call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
Rule 67    call_aux -> exp arg_function
Rule 68    call_aux -> exp arg_function COMMA call_aux
Rule 69    call_aux_2 -> exp arg_method
Rule 70    call_aux_2 -> exp arg_method COMMA call_aux_2
Rule 71    condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
Rule 72    condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif
Rule 73    condition_aux_elif -> empty
Rule 74    condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE
Rule 75    condition_aux_else -> empty
Rule 76    read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read
Rule 77    read_aux -> ID push_var
Rule 78    read_aux -> ID push_var COMMA generate_read read_aux
Rule 79    read_aux -> ID var_aux
Rule 80    read_aux -> ID var_aux COMMA generate_read read_aux
Rule 81    read_aux -> ID push_var var_aux_2
Rule 82    read_aux -> ID push_var var_aux_2 COMMA generate_read read_aux
Rule 83    write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
Rule 84    write_aux -> exp
Rule 85    write_aux -> exp COMMA generate_write write_aux
Rule 86    write_aux -> CTESTRING save_string
Rule 87    write_aux -> CTESTRING save_string COMMA generate_write write_aux
Rule 88    while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
Rule 89    for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for
Rule 90    exp -> l_exp pop_op_lop
Rule 91    exp -> l_exp pop_op_lop OR push_op exp
Rule 92    exp -> l_exp pop_op_lop AND push_op exp
Rule 93    l_exp -> a_exp
Rule 94    l_exp -> a_exp RELOP push_op a_exp pop_op_relop
Rule 95    a_exp -> term pop_op_art_n2
Rule 96    a_exp -> term pop_op_art_n2 PLUS push_op a_exp
Rule 97    a_exp -> term pop_op_art_n2 MINUS push_op a_exp
Rule 98    term -> factor pop_op_art_n1
Rule 99    term -> factor pop_op_art_n1 TIMES push_op term
Rule 100   term -> factor pop_op_art_n1 DIVIDE push_op term
Rule 101   factor -> LPAREN push_paren exp RPAREN pop_paren
Rule 102   factor -> factor_aux
Rule 103   factor -> call
Rule 104   factor_aux -> cte
Rule 105   factor_aux -> PLUS cte
Rule 106   factor_aux -> MINUS cte
Rule 107   cte -> ID push_var
Rule 108   cte -> ID var_aux
Rule 109   cte -> ID push_var var_aux_2
Rule 110   cte -> CTEI push_var
Rule 111   cte -> CTEF push_var
Rule 112   cte -> CTECHAR push_var
Rule 113   init -> INIT add_init LBRACE start_init statutes_aux RBRACE
Rule 114   init -> INIT add_init LBRACE start_init dec_vars statutes_aux RBRACE
Rule 115   empty -> <empty>
Rule 116   add_variable -> <empty>
Rule 117   add_array_variable -> <empty>
Rule 118   add_matrix_variable -> <empty>
Rule 119   add_function -> <empty>
Rule 120   add_init -> <empty>
Rule 121   add_class -> <empty>
Rule 122   add_inherit_class -> <empty>
Rule 123   push_var -> <empty>
Rule 124   push_op -> <empty>
Rule 125   push_obj_var -> <empty>
Rule 126   pop_op_art_n1 -> <empty>
Rule 127   pop_op_art_n2 -> <empty>
Rule 128   pop_op_relop -> <empty>
Rule 129   pop_op_lop -> <empty>
Rule 130   pop_op_assign -> <empty>
Rule 131   push_paren -> <empty>
Rule 132   pop_paren -> <empty>
Rule 133   generate_write -> <empty>
Rule 134   save_string -> <empty>
Rule 135   generate_read -> <empty>
Rule 136   if_condition -> <empty>
Rule 137   elif_condition -> <empty>
Rule 138   elif_expression -> <empty>
Rule 139   else_condition -> <empty>
Rule 140   end_if -> <empty>
Rule 141   while_jump -> <empty>
Rule 142   while_condition -> <empty>
Rule 143   end_while -> <empty>
Rule 144   for_jump -> <empty>
Rule 145   for_condition -> <empty>
Rule 146   end_for -> <empty>
Rule 147   add_param -> <empty>
Rule 148   insert_number_params -> <empty>
Rule 149   start_function -> <empty>
Rule 150   return_function -> <empty>
Rule 151   end_function -> <empty>
Rule 152   exist_function -> <empty>
Rule 153   era_function -> <empty>
Rule 154   arg_function -> <empty>
Rule 155   gosub_function -> <empty>
Rule 156   access_array -> <empty>
Rule 157   verify_array_index -> <empty>
Rule 158   end_array -> <empty>
Rule 159   access_matrix -> <empty>
Rule 160   verify_matrix_index -> <empty>
Rule 161   end_matrix -> <empty>
Rule 162   exist_method -> <empty>
Rule 163   era_method -> <empty>
Rule 164   arg_method -> <empty>
Rule 165   gosub_method -> <empty>
Rule 166   check_init -> <empty>
Rule 167   start_init -> <empty>
Rule 168   end_program -> <empty>

Terminals, with rules where they appear

AND                  : 92
CALL                 : 47
CHAR                 : 16
CLASS                : 27 28
COMMA                : 18 20 26 40 68 70 78 80 82 85 87
CTECHAR              : 112
CTEF                 : 111
CTEI                 : 21 22 22 110
CTESTRING            : 86 87
DIVIDE               : 100
DO                   : 88 89
ELIF                 : 72
ELSE                 : 74
END                  : 1
EQUAL                : 55 56 57
FLOAT                : 15
FROM                 : 89
FUNCT                : 33 34
ID                   : 1 17 18 19 20 25 26 35 36 37 38 39 40 43 44 45 55 56 57 58 59 63 64 64 65 66 66 77 78 79 80 81 82 107 108 109
IF                   : 71
INHERITS             : 31 32
INIT                 : 113 114
INT                  : 14
LBRACE               : 1 29 30 31 32 41 42 43 44 45 71 72 74 88 89 113 114
LBRACKET             : 21 22 22 60 61
LPAREN               : 35 36 37 38 63 64 65 66 71 72 76 83 88 89 89 101
MAIN                 : 1
MINUS                : 97 106
OBJECT               : 23 24 27 28 31 32
OR                   : 91
PLUS                 : 96 105
POINT                : 58 59 64 66
PROGRAM              : 1
RBRACE               : 1 29 30 31 32 41 42 43 44 45 71 72 74 88 89 113 114
RBRACKET             : 21 22 22 60 61
READ                 : 76
RELOP                : 94
RETURN               : 43 44 45
RPAREN               : 35 36 37 38 63 64 65 66 71 72 76 83 88 89 89 101
SEMICOLON            : 12 13 23 24 43 44 45 46 47 76 83
THEN                 : 71 72
TIMES                : 99
TWOPOINTS            : 1
UNTIL                : 89
VAR                  : 9
VOID                 : 35 36
WHILE                : 88
WRITE                : 83
error                : 

Nonterminals, with rules where they appear

a_exp                : 93 94 94 96 97
access_array         : 60
access_matrix        : 61
add_array_variable   : 21
add_class            : 1 29 30
add_function         : 35 36 37 38
add_inherit_class    : 31 32
add_init             : 113 114
add_matrix_variable  : 22
add_param            : 39 40
add_variable         : 17 18 25 26
arg_function         : 67 68
arg_method           : 69 70
assignation          : 46 89
body                 : 35 36 37 38
call                 : 47 103
call_aux             : 65 68
call_aux_2           : 66 70
check_init           : 1
classes              : 2 28
classes_aux          : 27 28
condition            : 50
condition_aux_elif   : 71 72
condition_aux_else   : 71
cte                  : 104 105 106
dec_vars             : 5 29 31 41 44 114
dec_vars_aux         : 9 13 24
dec_vars_complex     : 11
dec_vars_simple      : 10
elif_condition       : 72
elif_expression      : 72
else_condition       : 74
empty                : 3 6 8 73 75
end_array            : 62
end_for              : 89
end_function         : 41 42 43 44 45
end_if               : 71
end_matrix           : 61
end_program          : 1
end_while            : 88
era_function         : 63 65
era_method           : 64 66
exist_function       : 63 65
exist_method         : 64 66
exp                  : 55 56 57 60 61 67 68 69 70 71 72 84 85 88 89 91 92 101
factor               : 98 99 100
factor_aux           : 102
for                  : 52
for_condition        : 89
for_jump             : 89
functions            : 7 29 30 31 32 34
functions_aux        : 33 34
generate_read        : 76 78 80 82
generate_write       : 83 85 87
gosub_function       : 63 65
gosub_method         : 64 66
if_condition         : 71
init                 : 1
insert_number_params : 35 38
l_exp                : 90 91 92
params               : 35 38 40
pop_op_art_n1        : 98 99 100
pop_op_art_n2        : 95 96 97
pop_op_assign        : 55 56 57
pop_op_lop           : 90 91 92
pop_op_relop         : 94
pop_paren            : 65 66 101
program              : 0
program_body         : 1
program_body_funct   : 4
program_body_vars    : 4
program_classes      : 1
push_obj_var         : 58
push_op              : 55 56 57 91 92 94 96 97 99 100
push_paren           : 65 66 101
push_var             : 55 57 77 78 81 82 107 109 110 111 112
read                 : 48
read_aux             : 76 78 80 82
return_function      : 43 44 45
save_string          : 86 87
simple_type          : 12 13 37 38 39 40
start_function       : 41 42 43 44 45
start_init           : 113 114
statutes             : 53 54
statutes_aux         : 41 42 43 44 54 71 72 74 88 89 113 114
term                 : 95 96 97 99 100
var_aux              : 56 79 80 108
var_aux_2            : 57 59 81 82 109
var_aux_3            : 60
vars_complex_type    : 23 24 26
vars_simple_type     : 12 13 18 20
vars_simple_type_aux : 19 20
verify_array_index   : 60
verify_matrix_index  : 61
while                : 51
while_condition      : 88
while_jump           : 88
write                : 49
write_aux            : 83 85 87

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program

    TWOPOINTS       shift and go to state 4


state 4

    (1) program -> PROGRAM ID TWOPOINTS . check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program
    (166) check_init -> .

    CLASS           reduce using rule 166 (check_init -> .)
    MAIN            reduce using rule 166 (check_init -> .)

    check_init                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID TWOPOINTS check_init . program_classes MAIN add_class LBRACE program_body init RBRACE END end_program
    (2) program_classes -> . classes
    (3) program_classes -> . empty
    (27) classes -> . CLASS OBJECT classes_aux
    (28) classes -> . CLASS OBJECT classes_aux classes
    (115) empty -> .

    CLASS           shift and go to state 9
    MAIN            reduce using rule 115 (empty -> .)

    program_classes                shift and go to state 6
    classes                        shift and go to state 7
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes . MAIN add_class LBRACE program_body init RBRACE END end_program

    MAIN            shift and go to state 10


state 7

    (2) program_classes -> classes .

    MAIN            reduce using rule 2 (program_classes -> classes .)


state 8

    (3) program_classes -> empty .

    MAIN            reduce using rule 3 (program_classes -> empty .)


state 9

    (27) classes -> CLASS . OBJECT classes_aux
    (28) classes -> CLASS . OBJECT classes_aux classes

    OBJECT          shift and go to state 11


state 10

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN . add_class LBRACE program_body init RBRACE END end_program
    (121) add_class -> .

    LBRACE          reduce using rule 121 (add_class -> .)

    add_class                      shift and go to state 12

state 11

    (27) classes -> CLASS OBJECT . classes_aux
    (28) classes -> CLASS OBJECT . classes_aux classes
    (29) classes_aux -> . add_class LBRACE dec_vars functions RBRACE
    (30) classes_aux -> . add_class LBRACE functions RBRACE
    (31) classes_aux -> . INHERITS OBJECT add_inherit_class LBRACE dec_vars functions RBRACE
    (32) classes_aux -> . INHERITS OBJECT add_inherit_class LBRACE functions RBRACE
    (121) add_class -> .

    INHERITS        shift and go to state 15
    LBRACE          reduce using rule 121 (add_class -> .)

    classes_aux                    shift and go to state 13
    add_class                      shift and go to state 14

state 12

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class . LBRACE program_body init RBRACE END end_program

    LBRACE          shift and go to state 16


state 13

    (27) classes -> CLASS OBJECT classes_aux .
    (28) classes -> CLASS OBJECT classes_aux . classes
    (27) classes -> . CLASS OBJECT classes_aux
    (28) classes -> . CLASS OBJECT classes_aux classes

    MAIN            reduce using rule 27 (classes -> CLASS OBJECT classes_aux .)
    CLASS           shift and go to state 9

    classes                        shift and go to state 17

state 14

    (29) classes_aux -> add_class . LBRACE dec_vars functions RBRACE
    (30) classes_aux -> add_class . LBRACE functions RBRACE

    LBRACE          shift and go to state 18


state 15

    (31) classes_aux -> INHERITS . OBJECT add_inherit_class LBRACE dec_vars functions RBRACE
    (32) classes_aux -> INHERITS . OBJECT add_inherit_class LBRACE functions RBRACE

    OBJECT          shift and go to state 19


state 16

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE . program_body init RBRACE END end_program
    (4) program_body -> . program_body_vars program_body_funct
    (5) program_body_vars -> . dec_vars
    (6) program_body_vars -> . empty
    (9) dec_vars -> . VAR dec_vars_aux
    (115) empty -> .

    VAR             shift and go to state 24
    FUNCT           reduce using rule 115 (empty -> .)
    INIT            reduce using rule 115 (empty -> .)

    program_body                   shift and go to state 20
    program_body_vars              shift and go to state 21
    dec_vars                       shift and go to state 22
    empty                          shift and go to state 23

state 17

    (28) classes -> CLASS OBJECT classes_aux classes .

    MAIN            reduce using rule 28 (classes -> CLASS OBJECT classes_aux classes .)


state 18

    (29) classes_aux -> add_class LBRACE . dec_vars functions RBRACE
    (30) classes_aux -> add_class LBRACE . functions RBRACE
    (9) dec_vars -> . VAR dec_vars_aux
    (33) functions -> . FUNCT functions_aux
    (34) functions -> . FUNCT functions_aux functions

    VAR             shift and go to state 24
    FUNCT           shift and go to state 27

    dec_vars                       shift and go to state 25
    functions                      shift and go to state 26

state 19

    (31) classes_aux -> INHERITS OBJECT . add_inherit_class LBRACE dec_vars functions RBRACE
    (32) classes_aux -> INHERITS OBJECT . add_inherit_class LBRACE functions RBRACE
    (122) add_inherit_class -> .

    LBRACE          reduce using rule 122 (add_inherit_class -> .)

    add_inherit_class              shift and go to state 28

state 20

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body . init RBRACE END end_program
    (113) init -> . INIT add_init LBRACE start_init statutes_aux RBRACE
    (114) init -> . INIT add_init LBRACE start_init dec_vars statutes_aux RBRACE

    INIT            shift and go to state 30

    init                           shift and go to state 29

state 21

    (4) program_body -> program_body_vars . program_body_funct
    (7) program_body_funct -> . functions
    (8) program_body_funct -> . empty
    (33) functions -> . FUNCT functions_aux
    (34) functions -> . FUNCT functions_aux functions
    (115) empty -> .

    FUNCT           shift and go to state 27
    INIT            reduce using rule 115 (empty -> .)

    program_body_funct             shift and go to state 31
    functions                      shift and go to state 32
    empty                          shift and go to state 33

state 22

    (5) program_body_vars -> dec_vars .

    FUNCT           reduce using rule 5 (program_body_vars -> dec_vars .)
    INIT            reduce using rule 5 (program_body_vars -> dec_vars .)


state 23

    (6) program_body_vars -> empty .

    FUNCT           reduce using rule 6 (program_body_vars -> empty .)
    INIT            reduce using rule 6 (program_body_vars -> empty .)


state 24

    (9) dec_vars -> VAR . dec_vars_aux
    (10) dec_vars_aux -> . dec_vars_simple
    (11) dec_vars_aux -> . dec_vars_complex
    (12) dec_vars_simple -> . simple_type vars_simple_type SEMICOLON
    (13) dec_vars_simple -> . simple_type vars_simple_type SEMICOLON dec_vars_aux
    (23) dec_vars_complex -> . OBJECT vars_complex_type SEMICOLON
    (24) dec_vars_complex -> . OBJECT vars_complex_type SEMICOLON dec_vars_aux
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    OBJECT          shift and go to state 38
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    dec_vars_aux                   shift and go to state 34
    dec_vars_simple                shift and go to state 35
    dec_vars_complex               shift and go to state 36
    simple_type                    shift and go to state 37

state 25

    (29) classes_aux -> add_class LBRACE dec_vars . functions RBRACE
    (33) functions -> . FUNCT functions_aux
    (34) functions -> . FUNCT functions_aux functions

    FUNCT           shift and go to state 27

    functions                      shift and go to state 42

state 26

    (30) classes_aux -> add_class LBRACE functions . RBRACE

    RBRACE          shift and go to state 43


state 27

    (33) functions -> FUNCT . functions_aux
    (34) functions -> FUNCT . functions_aux functions
    (35) functions_aux -> . VOID ID add_function LPAREN params RPAREN insert_number_params body
    (36) functions_aux -> . VOID ID add_function LPAREN RPAREN body
    (37) functions_aux -> . simple_type ID add_function LPAREN RPAREN body
    (38) functions_aux -> . simple_type ID add_function LPAREN params RPAREN insert_number_params body
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    VOID            shift and go to state 45
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    functions_aux                  shift and go to state 44
    simple_type                    shift and go to state 46

state 28

    (31) classes_aux -> INHERITS OBJECT add_inherit_class . LBRACE dec_vars functions RBRACE
    (32) classes_aux -> INHERITS OBJECT add_inherit_class . LBRACE functions RBRACE

    LBRACE          shift and go to state 47


state 29

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init . RBRACE END end_program

    RBRACE          shift and go to state 48


state 30

    (113) init -> INIT . add_init LBRACE start_init statutes_aux RBRACE
    (114) init -> INIT . add_init LBRACE start_init dec_vars statutes_aux RBRACE
    (120) add_init -> .

    LBRACE          reduce using rule 120 (add_init -> .)

    add_init                       shift and go to state 49

state 31

    (4) program_body -> program_body_vars program_body_funct .

    INIT            reduce using rule 4 (program_body -> program_body_vars program_body_funct .)


state 32

    (7) program_body_funct -> functions .

    INIT            reduce using rule 7 (program_body_funct -> functions .)


state 33

    (8) program_body_funct -> empty .

    INIT            reduce using rule 8 (program_body_funct -> empty .)


state 34

    (9) dec_vars -> VAR dec_vars_aux .

    FUNCT           reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    INIT            reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    CALL            reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    ID              reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    READ            reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    WRITE           reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    IF              reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    WHILE           reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)
    FROM            reduce using rule 9 (dec_vars -> VAR dec_vars_aux .)


state 35

    (10) dec_vars_aux -> dec_vars_simple .

    FUNCT           reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    INIT            reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    CALL            reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    ID              reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    READ            reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    WRITE           reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    IF              reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    WHILE           reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)
    FROM            reduce using rule 10 (dec_vars_aux -> dec_vars_simple .)


state 36

    (11) dec_vars_aux -> dec_vars_complex .

    FUNCT           reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    INIT            reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    CALL            reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    ID              reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    READ            reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    WRITE           reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    IF              reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    WHILE           reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)
    FROM            reduce using rule 11 (dec_vars_aux -> dec_vars_complex .)


state 37

    (12) dec_vars_simple -> simple_type . vars_simple_type SEMICOLON
    (13) dec_vars_simple -> simple_type . vars_simple_type SEMICOLON dec_vars_aux
    (17) vars_simple_type -> . ID add_variable
    (18) vars_simple_type -> . ID add_variable COMMA vars_simple_type
    (19) vars_simple_type -> . ID vars_simple_type_aux
    (20) vars_simple_type -> . ID vars_simple_type_aux COMMA vars_simple_type

    ID              shift and go to state 51

    vars_simple_type               shift and go to state 50

state 38

    (23) dec_vars_complex -> OBJECT . vars_complex_type SEMICOLON
    (24) dec_vars_complex -> OBJECT . vars_complex_type SEMICOLON dec_vars_aux
    (25) vars_complex_type -> . ID add_variable
    (26) vars_complex_type -> . ID add_variable COMMA vars_complex_type

    ID              shift and go to state 53

    vars_complex_type              shift and go to state 52

state 39

    (14) simple_type -> INT .

    ID              reduce using rule 14 (simple_type -> INT .)


state 40

    (15) simple_type -> FLOAT .

    ID              reduce using rule 15 (simple_type -> FLOAT .)


state 41

    (16) simple_type -> CHAR .

    ID              reduce using rule 16 (simple_type -> CHAR .)


state 42

    (29) classes_aux -> add_class LBRACE dec_vars functions . RBRACE

    RBRACE          shift and go to state 54


state 43

    (30) classes_aux -> add_class LBRACE functions RBRACE .

    CLASS           reduce using rule 30 (classes_aux -> add_class LBRACE functions RBRACE .)
    MAIN            reduce using rule 30 (classes_aux -> add_class LBRACE functions RBRACE .)


state 44

    (33) functions -> FUNCT functions_aux .
    (34) functions -> FUNCT functions_aux . functions
    (33) functions -> . FUNCT functions_aux
    (34) functions -> . FUNCT functions_aux functions

    RBRACE          reduce using rule 33 (functions -> FUNCT functions_aux .)
    INIT            reduce using rule 33 (functions -> FUNCT functions_aux .)
    FUNCT           shift and go to state 27

    functions                      shift and go to state 55

state 45

    (35) functions_aux -> VOID . ID add_function LPAREN params RPAREN insert_number_params body
    (36) functions_aux -> VOID . ID add_function LPAREN RPAREN body

    ID              shift and go to state 56


state 46

    (37) functions_aux -> simple_type . ID add_function LPAREN RPAREN body
    (38) functions_aux -> simple_type . ID add_function LPAREN params RPAREN insert_number_params body

    ID              shift and go to state 57


state 47

    (31) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE . dec_vars functions RBRACE
    (32) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE . functions RBRACE
    (9) dec_vars -> . VAR dec_vars_aux
    (33) functions -> . FUNCT functions_aux
    (34) functions -> . FUNCT functions_aux functions

    VAR             shift and go to state 24
    FUNCT           shift and go to state 27

    dec_vars                       shift and go to state 58
    functions                      shift and go to state 59

state 48

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE . END end_program

    END             shift and go to state 60


state 49

    (113) init -> INIT add_init . LBRACE start_init statutes_aux RBRACE
    (114) init -> INIT add_init . LBRACE start_init dec_vars statutes_aux RBRACE

    LBRACE          shift and go to state 61


state 50

    (12) dec_vars_simple -> simple_type vars_simple_type . SEMICOLON
    (13) dec_vars_simple -> simple_type vars_simple_type . SEMICOLON dec_vars_aux

    SEMICOLON       shift and go to state 62


state 51

    (17) vars_simple_type -> ID . add_variable
    (18) vars_simple_type -> ID . add_variable COMMA vars_simple_type
    (19) vars_simple_type -> ID . vars_simple_type_aux
    (20) vars_simple_type -> ID . vars_simple_type_aux COMMA vars_simple_type
    (116) add_variable -> .
    (21) vars_simple_type_aux -> . LBRACKET CTEI RBRACKET add_array_variable
    (22) vars_simple_type_aux -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable

    COMMA           reduce using rule 116 (add_variable -> .)
    SEMICOLON       reduce using rule 116 (add_variable -> .)
    LBRACKET        shift and go to state 65

    add_variable                   shift and go to state 63
    vars_simple_type_aux           shift and go to state 64

state 52

    (23) dec_vars_complex -> OBJECT vars_complex_type . SEMICOLON
    (24) dec_vars_complex -> OBJECT vars_complex_type . SEMICOLON dec_vars_aux

    SEMICOLON       shift and go to state 66


state 53

    (25) vars_complex_type -> ID . add_variable
    (26) vars_complex_type -> ID . add_variable COMMA vars_complex_type
    (116) add_variable -> .

    COMMA           reduce using rule 116 (add_variable -> .)
    SEMICOLON       reduce using rule 116 (add_variable -> .)

    add_variable                   shift and go to state 67

state 54

    (29) classes_aux -> add_class LBRACE dec_vars functions RBRACE .

    CLASS           reduce using rule 29 (classes_aux -> add_class LBRACE dec_vars functions RBRACE .)
    MAIN            reduce using rule 29 (classes_aux -> add_class LBRACE dec_vars functions RBRACE .)


state 55

    (34) functions -> FUNCT functions_aux functions .

    RBRACE          reduce using rule 34 (functions -> FUNCT functions_aux functions .)
    INIT            reduce using rule 34 (functions -> FUNCT functions_aux functions .)


state 56

    (35) functions_aux -> VOID ID . add_function LPAREN params RPAREN insert_number_params body
    (36) functions_aux -> VOID ID . add_function LPAREN RPAREN body
    (119) add_function -> .

    LPAREN          reduce using rule 119 (add_function -> .)

    add_function                   shift and go to state 68

state 57

    (37) functions_aux -> simple_type ID . add_function LPAREN RPAREN body
    (38) functions_aux -> simple_type ID . add_function LPAREN params RPAREN insert_number_params body
    (119) add_function -> .

    LPAREN          reduce using rule 119 (add_function -> .)

    add_function                   shift and go to state 69

state 58

    (31) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE dec_vars . functions RBRACE
    (33) functions -> . FUNCT functions_aux
    (34) functions -> . FUNCT functions_aux functions

    FUNCT           shift and go to state 27

    functions                      shift and go to state 70

state 59

    (32) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE functions . RBRACE

    RBRACE          shift and go to state 71


state 60

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END . end_program
    (168) end_program -> .

    $end            reduce using rule 168 (end_program -> .)

    end_program                    shift and go to state 72

state 61

    (113) init -> INIT add_init LBRACE . start_init statutes_aux RBRACE
    (114) init -> INIT add_init LBRACE . start_init dec_vars statutes_aux RBRACE
    (167) start_init -> .

    VAR             reduce using rule 167 (start_init -> .)
    CALL            reduce using rule 167 (start_init -> .)
    ID              reduce using rule 167 (start_init -> .)
    READ            reduce using rule 167 (start_init -> .)
    WRITE           reduce using rule 167 (start_init -> .)
    IF              reduce using rule 167 (start_init -> .)
    WHILE           reduce using rule 167 (start_init -> .)
    FROM            reduce using rule 167 (start_init -> .)

    start_init                     shift and go to state 73

state 62

    (12) dec_vars_simple -> simple_type vars_simple_type SEMICOLON .
    (13) dec_vars_simple -> simple_type vars_simple_type SEMICOLON . dec_vars_aux
    (10) dec_vars_aux -> . dec_vars_simple
    (11) dec_vars_aux -> . dec_vars_complex
    (12) dec_vars_simple -> . simple_type vars_simple_type SEMICOLON
    (13) dec_vars_simple -> . simple_type vars_simple_type SEMICOLON dec_vars_aux
    (23) dec_vars_complex -> . OBJECT vars_complex_type SEMICOLON
    (24) dec_vars_complex -> . OBJECT vars_complex_type SEMICOLON dec_vars_aux
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    FUNCT           reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    INIT            reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    CALL            reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    ID              reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    READ            reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    WRITE           reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    IF              reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    WHILE           reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    FROM            reduce using rule 12 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON .)
    OBJECT          shift and go to state 38
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    simple_type                    shift and go to state 37
    dec_vars_aux                   shift and go to state 74
    dec_vars_simple                shift and go to state 35
    dec_vars_complex               shift and go to state 36

state 63

    (17) vars_simple_type -> ID add_variable .
    (18) vars_simple_type -> ID add_variable . COMMA vars_simple_type

    SEMICOLON       reduce using rule 17 (vars_simple_type -> ID add_variable .)
    COMMA           shift and go to state 75


state 64

    (19) vars_simple_type -> ID vars_simple_type_aux .
    (20) vars_simple_type -> ID vars_simple_type_aux . COMMA vars_simple_type

    SEMICOLON       reduce using rule 19 (vars_simple_type -> ID vars_simple_type_aux .)
    COMMA           shift and go to state 76


state 65

    (21) vars_simple_type_aux -> LBRACKET . CTEI RBRACKET add_array_variable
    (22) vars_simple_type_aux -> LBRACKET . CTEI RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable

    CTEI            shift and go to state 77


state 66

    (23) dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .
    (24) dec_vars_complex -> OBJECT vars_complex_type SEMICOLON . dec_vars_aux
    (10) dec_vars_aux -> . dec_vars_simple
    (11) dec_vars_aux -> . dec_vars_complex
    (12) dec_vars_simple -> . simple_type vars_simple_type SEMICOLON
    (13) dec_vars_simple -> . simple_type vars_simple_type SEMICOLON dec_vars_aux
    (23) dec_vars_complex -> . OBJECT vars_complex_type SEMICOLON
    (24) dec_vars_complex -> . OBJECT vars_complex_type SEMICOLON dec_vars_aux
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    FUNCT           reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    INIT            reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    CALL            reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    ID              reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    READ            reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    WRITE           reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    IF              reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    WHILE           reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    FROM            reduce using rule 23 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON .)
    OBJECT          shift and go to state 38
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    dec_vars_aux                   shift and go to state 78
    dec_vars_simple                shift and go to state 35
    dec_vars_complex               shift and go to state 36
    simple_type                    shift and go to state 37

state 67

    (25) vars_complex_type -> ID add_variable .
    (26) vars_complex_type -> ID add_variable . COMMA vars_complex_type

    SEMICOLON       reduce using rule 25 (vars_complex_type -> ID add_variable .)
    COMMA           shift and go to state 79


state 68

    (35) functions_aux -> VOID ID add_function . LPAREN params RPAREN insert_number_params body
    (36) functions_aux -> VOID ID add_function . LPAREN RPAREN body

    LPAREN          shift and go to state 80


state 69

    (37) functions_aux -> simple_type ID add_function . LPAREN RPAREN body
    (38) functions_aux -> simple_type ID add_function . LPAREN params RPAREN insert_number_params body

    LPAREN          shift and go to state 81


state 70

    (31) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE dec_vars functions . RBRACE

    RBRACE          shift and go to state 82


state 71

    (32) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE functions RBRACE .

    CLASS           reduce using rule 32 (classes_aux -> INHERITS OBJECT add_inherit_class LBRACE functions RBRACE .)
    MAIN            reduce using rule 32 (classes_aux -> INHERITS OBJECT add_inherit_class LBRACE functions RBRACE .)


state 72

    (1) program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program .

    $end            reduce using rule 1 (program -> PROGRAM ID TWOPOINTS check_init program_classes MAIN add_class LBRACE program_body init RBRACE END end_program .)


state 73

    (113) init -> INIT add_init LBRACE start_init . statutes_aux RBRACE
    (114) init -> INIT add_init LBRACE start_init . dec_vars statutes_aux RBRACE
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (9) dec_vars -> . VAR dec_vars_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    VAR             shift and go to state 24
    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 83
    dec_vars                       shift and go to state 84
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 74

    (13) dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .

    FUNCT           reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    INIT            reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    CALL            reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    ID              reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    READ            reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    WRITE           reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    IF              reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    WHILE           reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)
    FROM            reduce using rule 13 (dec_vars_simple -> simple_type vars_simple_type SEMICOLON dec_vars_aux .)


state 75

    (18) vars_simple_type -> ID add_variable COMMA . vars_simple_type
    (17) vars_simple_type -> . ID add_variable
    (18) vars_simple_type -> . ID add_variable COMMA vars_simple_type
    (19) vars_simple_type -> . ID vars_simple_type_aux
    (20) vars_simple_type -> . ID vars_simple_type_aux COMMA vars_simple_type

    ID              shift and go to state 51

    vars_simple_type               shift and go to state 99

state 76

    (20) vars_simple_type -> ID vars_simple_type_aux COMMA . vars_simple_type
    (17) vars_simple_type -> . ID add_variable
    (18) vars_simple_type -> . ID add_variable COMMA vars_simple_type
    (19) vars_simple_type -> . ID vars_simple_type_aux
    (20) vars_simple_type -> . ID vars_simple_type_aux COMMA vars_simple_type

    ID              shift and go to state 51

    vars_simple_type               shift and go to state 100

state 77

    (21) vars_simple_type_aux -> LBRACKET CTEI . RBRACKET add_array_variable
    (22) vars_simple_type_aux -> LBRACKET CTEI . RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable

    RBRACKET        shift and go to state 101


state 78

    (24) dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .

    FUNCT           reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    INIT            reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    CALL            reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    ID              reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    READ            reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    WRITE           reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    IF              reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    WHILE           reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)
    FROM            reduce using rule 24 (dec_vars_complex -> OBJECT vars_complex_type SEMICOLON dec_vars_aux .)


state 79

    (26) vars_complex_type -> ID add_variable COMMA . vars_complex_type
    (25) vars_complex_type -> . ID add_variable
    (26) vars_complex_type -> . ID add_variable COMMA vars_complex_type

    ID              shift and go to state 53

    vars_complex_type              shift and go to state 102

state 80

    (35) functions_aux -> VOID ID add_function LPAREN . params RPAREN insert_number_params body
    (36) functions_aux -> VOID ID add_function LPAREN . RPAREN body
    (39) params -> . simple_type ID add_param
    (40) params -> . simple_type ID add_param COMMA params
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    RPAREN          shift and go to state 104
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    params                         shift and go to state 103
    simple_type                    shift and go to state 105

state 81

    (37) functions_aux -> simple_type ID add_function LPAREN . RPAREN body
    (38) functions_aux -> simple_type ID add_function LPAREN . params RPAREN insert_number_params body
    (39) params -> . simple_type ID add_param
    (40) params -> . simple_type ID add_param COMMA params
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    RPAREN          shift and go to state 106
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    simple_type                    shift and go to state 105
    params                         shift and go to state 107

state 82

    (31) classes_aux -> INHERITS OBJECT add_inherit_class LBRACE dec_vars functions RBRACE .

    CLASS           reduce using rule 31 (classes_aux -> INHERITS OBJECT add_inherit_class LBRACE dec_vars functions RBRACE .)
    MAIN            reduce using rule 31 (classes_aux -> INHERITS OBJECT add_inherit_class LBRACE dec_vars functions RBRACE .)


state 83

    (113) init -> INIT add_init LBRACE start_init statutes_aux . RBRACE

    RBRACE          shift and go to state 108


state 84

    (114) init -> INIT add_init LBRACE start_init dec_vars . statutes_aux RBRACE
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 109
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 85

    (53) statutes_aux -> statutes .
    (54) statutes_aux -> statutes . statutes_aux
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    RBRACE          reduce using rule 53 (statutes_aux -> statutes .)
    RETURN          reduce using rule 53 (statutes_aux -> statutes .)
    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes                       shift and go to state 85
    statutes_aux                   shift and go to state 110
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 86

    (46) statutes -> assignation . SEMICOLON

    SEMICOLON       shift and go to state 111


state 87

    (47) statutes -> CALL . call SEMICOLON
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method

    ID              shift and go to state 113

    call                           shift and go to state 112

state 88

    (48) statutes -> read .

    CALL            reduce using rule 48 (statutes -> read .)
    ID              reduce using rule 48 (statutes -> read .)
    READ            reduce using rule 48 (statutes -> read .)
    WRITE           reduce using rule 48 (statutes -> read .)
    IF              reduce using rule 48 (statutes -> read .)
    WHILE           reduce using rule 48 (statutes -> read .)
    FROM            reduce using rule 48 (statutes -> read .)
    RBRACE          reduce using rule 48 (statutes -> read .)
    RETURN          reduce using rule 48 (statutes -> read .)


state 89

    (49) statutes -> write .

    CALL            reduce using rule 49 (statutes -> write .)
    ID              reduce using rule 49 (statutes -> write .)
    READ            reduce using rule 49 (statutes -> write .)
    WRITE           reduce using rule 49 (statutes -> write .)
    IF              reduce using rule 49 (statutes -> write .)
    WHILE           reduce using rule 49 (statutes -> write .)
    FROM            reduce using rule 49 (statutes -> write .)
    RBRACE          reduce using rule 49 (statutes -> write .)
    RETURN          reduce using rule 49 (statutes -> write .)


state 90

    (50) statutes -> condition .

    CALL            reduce using rule 50 (statutes -> condition .)
    ID              reduce using rule 50 (statutes -> condition .)
    READ            reduce using rule 50 (statutes -> condition .)
    WRITE           reduce using rule 50 (statutes -> condition .)
    IF              reduce using rule 50 (statutes -> condition .)
    WHILE           reduce using rule 50 (statutes -> condition .)
    FROM            reduce using rule 50 (statutes -> condition .)
    RBRACE          reduce using rule 50 (statutes -> condition .)
    RETURN          reduce using rule 50 (statutes -> condition .)


state 91

    (51) statutes -> while .

    CALL            reduce using rule 51 (statutes -> while .)
    ID              reduce using rule 51 (statutes -> while .)
    READ            reduce using rule 51 (statutes -> while .)
    WRITE           reduce using rule 51 (statutes -> while .)
    IF              reduce using rule 51 (statutes -> while .)
    WHILE           reduce using rule 51 (statutes -> while .)
    FROM            reduce using rule 51 (statutes -> while .)
    RBRACE          reduce using rule 51 (statutes -> while .)
    RETURN          reduce using rule 51 (statutes -> while .)


state 92

    (52) statutes -> for .

    CALL            reduce using rule 52 (statutes -> for .)
    ID              reduce using rule 52 (statutes -> for .)
    READ            reduce using rule 52 (statutes -> for .)
    WRITE           reduce using rule 52 (statutes -> for .)
    IF              reduce using rule 52 (statutes -> for .)
    WHILE           reduce using rule 52 (statutes -> for .)
    FROM            reduce using rule 52 (statutes -> for .)
    RBRACE          reduce using rule 52 (statutes -> for .)
    RETURN          reduce using rule 52 (statutes -> for .)


state 93

    (55) assignation -> ID . push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> ID . var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> ID . push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (123) push_var -> .
    (58) var_aux -> . POINT ID push_obj_var
    (59) var_aux -> . POINT ID var_aux_2

    EQUAL           reduce using rule 123 (push_var -> .)
    LBRACKET        reduce using rule 123 (push_var -> .)
    POINT           shift and go to state 116

    push_var                       shift and go to state 114
    var_aux                        shift and go to state 115

state 94

    (76) read -> READ . LPAREN read_aux RPAREN SEMICOLON generate_read

    LPAREN          shift and go to state 117


state 95

    (83) write -> WRITE . LPAREN write_aux RPAREN SEMICOLON generate_write

    LPAREN          shift and go to state 118


state 96

    (71) condition -> IF . LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if

    LPAREN          shift and go to state 119


state 97

    (88) while -> WHILE . while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (141) while_jump -> .

    LPAREN          reduce using rule 141 (while_jump -> .)

    while_jump                     shift and go to state 120

state 98

    (89) for -> FROM . LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    LPAREN          shift and go to state 121


state 99

    (18) vars_simple_type -> ID add_variable COMMA vars_simple_type .

    SEMICOLON       reduce using rule 18 (vars_simple_type -> ID add_variable COMMA vars_simple_type .)


state 100

    (20) vars_simple_type -> ID vars_simple_type_aux COMMA vars_simple_type .

    SEMICOLON       reduce using rule 20 (vars_simple_type -> ID vars_simple_type_aux COMMA vars_simple_type .)


state 101

    (21) vars_simple_type_aux -> LBRACKET CTEI RBRACKET . add_array_variable
    (22) vars_simple_type_aux -> LBRACKET CTEI RBRACKET . LBRACKET CTEI RBRACKET add_matrix_variable
    (117) add_array_variable -> .

    LBRACKET        shift and go to state 122
    COMMA           reduce using rule 117 (add_array_variable -> .)
    SEMICOLON       reduce using rule 117 (add_array_variable -> .)

    add_array_variable             shift and go to state 123

state 102

    (26) vars_complex_type -> ID add_variable COMMA vars_complex_type .

    SEMICOLON       reduce using rule 26 (vars_complex_type -> ID add_variable COMMA vars_complex_type .)


state 103

    (35) functions_aux -> VOID ID add_function LPAREN params . RPAREN insert_number_params body

    RPAREN          shift and go to state 124


state 104

    (36) functions_aux -> VOID ID add_function LPAREN RPAREN . body
    (41) body -> . LBRACE start_function dec_vars statutes_aux RBRACE end_function
    (42) body -> . LBRACE start_function statutes_aux RBRACE end_function
    (43) body -> . LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (44) body -> . LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (45) body -> . LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function

    LBRACE          shift and go to state 126

    body                           shift and go to state 125

state 105

    (39) params -> simple_type . ID add_param
    (40) params -> simple_type . ID add_param COMMA params

    ID              shift and go to state 127


state 106

    (37) functions_aux -> simple_type ID add_function LPAREN RPAREN . body
    (41) body -> . LBRACE start_function dec_vars statutes_aux RBRACE end_function
    (42) body -> . LBRACE start_function statutes_aux RBRACE end_function
    (43) body -> . LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (44) body -> . LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (45) body -> . LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function

    LBRACE          shift and go to state 126

    body                           shift and go to state 128

state 107

    (38) functions_aux -> simple_type ID add_function LPAREN params . RPAREN insert_number_params body

    RPAREN          shift and go to state 129


state 108

    (113) init -> INIT add_init LBRACE start_init statutes_aux RBRACE .

    RBRACE          reduce using rule 113 (init -> INIT add_init LBRACE start_init statutes_aux RBRACE .)


state 109

    (114) init -> INIT add_init LBRACE start_init dec_vars statutes_aux . RBRACE

    RBRACE          shift and go to state 130


state 110

    (54) statutes_aux -> statutes statutes_aux .

    RBRACE          reduce using rule 54 (statutes_aux -> statutes statutes_aux .)
    RETURN          reduce using rule 54 (statutes_aux -> statutes statutes_aux .)


state 111

    (46) statutes -> assignation SEMICOLON .

    CALL            reduce using rule 46 (statutes -> assignation SEMICOLON .)
    ID              reduce using rule 46 (statutes -> assignation SEMICOLON .)
    READ            reduce using rule 46 (statutes -> assignation SEMICOLON .)
    WRITE           reduce using rule 46 (statutes -> assignation SEMICOLON .)
    IF              reduce using rule 46 (statutes -> assignation SEMICOLON .)
    WHILE           reduce using rule 46 (statutes -> assignation SEMICOLON .)
    FROM            reduce using rule 46 (statutes -> assignation SEMICOLON .)
    RBRACE          reduce using rule 46 (statutes -> assignation SEMICOLON .)
    RETURN          reduce using rule 46 (statutes -> assignation SEMICOLON .)


state 112

    (47) statutes -> CALL call . SEMICOLON

    SEMICOLON       shift and go to state 131


state 113

    (63) call -> ID . exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> ID . POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> ID . exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> ID . POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (152) exist_function -> .

    POINT           shift and go to state 133
    LPAREN          reduce using rule 152 (exist_function -> .)

    exist_function                 shift and go to state 132

state 114

    (55) assignation -> ID push_var . EQUAL push_op exp pop_op_assign
    (57) assignation -> ID push_var . var_aux_2 EQUAL push_op exp pop_op_assign
    (60) var_aux_2 -> . LBRACKET access_array exp verify_array_index RBRACKET var_aux_3

    EQUAL           shift and go to state 134
    LBRACKET        shift and go to state 136

    var_aux_2                      shift and go to state 135

state 115

    (56) assignation -> ID var_aux . EQUAL push_op exp pop_op_assign

    EQUAL           shift and go to state 137


state 116

    (58) var_aux -> POINT . ID push_obj_var
    (59) var_aux -> POINT . ID var_aux_2

    ID              shift and go to state 138


state 117

    (76) read -> READ LPAREN . read_aux RPAREN SEMICOLON generate_read
    (77) read_aux -> . ID push_var
    (78) read_aux -> . ID push_var COMMA generate_read read_aux
    (79) read_aux -> . ID var_aux
    (80) read_aux -> . ID var_aux COMMA generate_read read_aux
    (81) read_aux -> . ID push_var var_aux_2
    (82) read_aux -> . ID push_var var_aux_2 COMMA generate_read read_aux

    ID              shift and go to state 140

    read_aux                       shift and go to state 139

state 118

    (83) write -> WRITE LPAREN . write_aux RPAREN SEMICOLON generate_write
    (84) write_aux -> . exp
    (85) write_aux -> . exp COMMA generate_write write_aux
    (86) write_aux -> . CTESTRING save_string
    (87) write_aux -> . CTESTRING save_string COMMA generate_write write_aux
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    CTESTRING       shift and go to state 144
    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    write_aux                      shift and go to state 142
    exp                            shift and go to state 143
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 119

    (71) condition -> IF LPAREN . exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 158
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 120

    (88) while -> WHILE while_jump . LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while

    LPAREN          shift and go to state 159


state 121

    (89) for -> FROM LPAREN . assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign

    ID              shift and go to state 93

    assignation                    shift and go to state 160

state 122

    (22) vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET . CTEI RBRACKET add_matrix_variable

    CTEI            shift and go to state 161


state 123

    (21) vars_simple_type_aux -> LBRACKET CTEI RBRACKET add_array_variable .

    COMMA           reduce using rule 21 (vars_simple_type_aux -> LBRACKET CTEI RBRACKET add_array_variable .)
    SEMICOLON       reduce using rule 21 (vars_simple_type_aux -> LBRACKET CTEI RBRACKET add_array_variable .)


state 124

    (35) functions_aux -> VOID ID add_function LPAREN params RPAREN . insert_number_params body
    (148) insert_number_params -> .

    LBRACE          reduce using rule 148 (insert_number_params -> .)

    insert_number_params           shift and go to state 162

state 125

    (36) functions_aux -> VOID ID add_function LPAREN RPAREN body .

    FUNCT           reduce using rule 36 (functions_aux -> VOID ID add_function LPAREN RPAREN body .)
    RBRACE          reduce using rule 36 (functions_aux -> VOID ID add_function LPAREN RPAREN body .)
    INIT            reduce using rule 36 (functions_aux -> VOID ID add_function LPAREN RPAREN body .)


state 126

    (41) body -> LBRACE . start_function dec_vars statutes_aux RBRACE end_function
    (42) body -> LBRACE . start_function statutes_aux RBRACE end_function
    (43) body -> LBRACE . start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (44) body -> LBRACE . start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (45) body -> LBRACE . start_function RETURN ID return_function SEMICOLON RBRACE end_function
    (149) start_function -> .

    RETURN          reduce using rule 149 (start_function -> .)
    VAR             reduce using rule 149 (start_function -> .)
    CALL            reduce using rule 149 (start_function -> .)
    ID              reduce using rule 149 (start_function -> .)
    READ            reduce using rule 149 (start_function -> .)
    WRITE           reduce using rule 149 (start_function -> .)
    IF              reduce using rule 149 (start_function -> .)
    WHILE           reduce using rule 149 (start_function -> .)
    FROM            reduce using rule 149 (start_function -> .)

    start_function                 shift and go to state 163

state 127

    (39) params -> simple_type ID . add_param
    (40) params -> simple_type ID . add_param COMMA params
    (147) add_param -> .

    COMMA           reduce using rule 147 (add_param -> .)
    RPAREN          reduce using rule 147 (add_param -> .)

    add_param                      shift and go to state 164

state 128

    (37) functions_aux -> simple_type ID add_function LPAREN RPAREN body .

    FUNCT           reduce using rule 37 (functions_aux -> simple_type ID add_function LPAREN RPAREN body .)
    RBRACE          reduce using rule 37 (functions_aux -> simple_type ID add_function LPAREN RPAREN body .)
    INIT            reduce using rule 37 (functions_aux -> simple_type ID add_function LPAREN RPAREN body .)


state 129

    (38) functions_aux -> simple_type ID add_function LPAREN params RPAREN . insert_number_params body
    (148) insert_number_params -> .

    LBRACE          reduce using rule 148 (insert_number_params -> .)

    insert_number_params           shift and go to state 165

state 130

    (114) init -> INIT add_init LBRACE start_init dec_vars statutes_aux RBRACE .

    RBRACE          reduce using rule 114 (init -> INIT add_init LBRACE start_init dec_vars statutes_aux RBRACE .)


state 131

    (47) statutes -> CALL call SEMICOLON .

    CALL            reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    ID              reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    READ            reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    WRITE           reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    IF              reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    WHILE           reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    FROM            reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    RBRACE          reduce using rule 47 (statutes -> CALL call SEMICOLON .)
    RETURN          reduce using rule 47 (statutes -> CALL call SEMICOLON .)


state 132

    (63) call -> ID exist_function . LPAREN era_function RPAREN gosub_function
    (65) call -> ID exist_function . LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function

    LPAREN          shift and go to state 166


state 133

    (64) call -> ID POINT . ID exist_method LPAREN era_method RPAREN gosub_method
    (66) call -> ID POINT . ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method

    ID              shift and go to state 167


state 134

    (55) assignation -> ID push_var EQUAL . push_op exp pop_op_assign
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 168

state 135

    (57) assignation -> ID push_var var_aux_2 . EQUAL push_op exp pop_op_assign

    EQUAL           shift and go to state 169


state 136

    (60) var_aux_2 -> LBRACKET . access_array exp verify_array_index RBRACKET var_aux_3
    (156) access_array -> .

    LPAREN          reduce using rule 156 (access_array -> .)
    PLUS            reduce using rule 156 (access_array -> .)
    MINUS           reduce using rule 156 (access_array -> .)
    ID              reduce using rule 156 (access_array -> .)
    CTEI            reduce using rule 156 (access_array -> .)
    CTEF            reduce using rule 156 (access_array -> .)
    CTECHAR         reduce using rule 156 (access_array -> .)

    access_array                   shift and go to state 170

state 137

    (56) assignation -> ID var_aux EQUAL . push_op exp pop_op_assign
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 171

state 138

    (58) var_aux -> POINT ID . push_obj_var
    (59) var_aux -> POINT ID . var_aux_2
    (125) push_obj_var -> .
    (60) var_aux_2 -> . LBRACKET access_array exp verify_array_index RBRACKET var_aux_3

    EQUAL           reduce using rule 125 (push_obj_var -> .)
    COMMA           reduce using rule 125 (push_obj_var -> .)
    RPAREN          reduce using rule 125 (push_obj_var -> .)
    TIMES           reduce using rule 125 (push_obj_var -> .)
    DIVIDE          reduce using rule 125 (push_obj_var -> .)
    PLUS            reduce using rule 125 (push_obj_var -> .)
    MINUS           reduce using rule 125 (push_obj_var -> .)
    RELOP           reduce using rule 125 (push_obj_var -> .)
    OR              reduce using rule 125 (push_obj_var -> .)
    AND             reduce using rule 125 (push_obj_var -> .)
    SEMICOLON       reduce using rule 125 (push_obj_var -> .)
    RBRACKET        reduce using rule 125 (push_obj_var -> .)
    LBRACKET        shift and go to state 136

    push_obj_var                   shift and go to state 172
    var_aux_2                      shift and go to state 173

state 139

    (76) read -> READ LPAREN read_aux . RPAREN SEMICOLON generate_read

    RPAREN          shift and go to state 174


state 140

    (77) read_aux -> ID . push_var
    (78) read_aux -> ID . push_var COMMA generate_read read_aux
    (79) read_aux -> ID . var_aux
    (80) read_aux -> ID . var_aux COMMA generate_read read_aux
    (81) read_aux -> ID . push_var var_aux_2
    (82) read_aux -> ID . push_var var_aux_2 COMMA generate_read read_aux
    (123) push_var -> .
    (58) var_aux -> . POINT ID push_obj_var
    (59) var_aux -> . POINT ID var_aux_2

    COMMA           reduce using rule 123 (push_var -> .)
    LBRACKET        reduce using rule 123 (push_var -> .)
    RPAREN          reduce using rule 123 (push_var -> .)
    POINT           shift and go to state 116

    push_var                       shift and go to state 175
    var_aux                        shift and go to state 176

state 141

    (101) factor -> LPAREN . push_paren exp RPAREN pop_paren
    (131) push_paren -> .

    LPAREN          reduce using rule 131 (push_paren -> .)
    PLUS            reduce using rule 131 (push_paren -> .)
    MINUS           reduce using rule 131 (push_paren -> .)
    ID              reduce using rule 131 (push_paren -> .)
    CTEI            reduce using rule 131 (push_paren -> .)
    CTEF            reduce using rule 131 (push_paren -> .)
    CTECHAR         reduce using rule 131 (push_paren -> .)

    push_paren                     shift and go to state 177

state 142

    (83) write -> WRITE LPAREN write_aux . RPAREN SEMICOLON generate_write

    RPAREN          shift and go to state 178


state 143

    (84) write_aux -> exp .
    (85) write_aux -> exp . COMMA generate_write write_aux

    RPAREN          reduce using rule 84 (write_aux -> exp .)
    COMMA           shift and go to state 179


state 144

    (86) write_aux -> CTESTRING . save_string
    (87) write_aux -> CTESTRING . save_string COMMA generate_write write_aux
    (134) save_string -> .

    COMMA           reduce using rule 134 (save_string -> .)
    RPAREN          reduce using rule 134 (save_string -> .)

    save_string                    shift and go to state 180

state 145

    (90) exp -> l_exp . pop_op_lop
    (91) exp -> l_exp . pop_op_lop OR push_op exp
    (92) exp -> l_exp . pop_op_lop AND push_op exp
    (129) pop_op_lop -> .

    OR              reduce using rule 129 (pop_op_lop -> .)
    AND             reduce using rule 129 (pop_op_lop -> .)
    COMMA           reduce using rule 129 (pop_op_lop -> .)
    RPAREN          reduce using rule 129 (pop_op_lop -> .)
    SEMICOLON       reduce using rule 129 (pop_op_lop -> .)
    RBRACKET        reduce using rule 129 (pop_op_lop -> .)

    pop_op_lop                     shift and go to state 181

state 146

    (93) l_exp -> a_exp .
    (94) l_exp -> a_exp . RELOP push_op a_exp pop_op_relop

    OR              reduce using rule 93 (l_exp -> a_exp .)
    AND             reduce using rule 93 (l_exp -> a_exp .)
    COMMA           reduce using rule 93 (l_exp -> a_exp .)
    RPAREN          reduce using rule 93 (l_exp -> a_exp .)
    SEMICOLON       reduce using rule 93 (l_exp -> a_exp .)
    RBRACKET        reduce using rule 93 (l_exp -> a_exp .)
    RELOP           shift and go to state 182


state 147

    (95) a_exp -> term . pop_op_art_n2
    (96) a_exp -> term . pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> term . pop_op_art_n2 MINUS push_op a_exp
    (127) pop_op_art_n2 -> .

    PLUS            reduce using rule 127 (pop_op_art_n2 -> .)
    MINUS           reduce using rule 127 (pop_op_art_n2 -> .)
    RELOP           reduce using rule 127 (pop_op_art_n2 -> .)
    OR              reduce using rule 127 (pop_op_art_n2 -> .)
    AND             reduce using rule 127 (pop_op_art_n2 -> .)
    COMMA           reduce using rule 127 (pop_op_art_n2 -> .)
    RPAREN          reduce using rule 127 (pop_op_art_n2 -> .)
    SEMICOLON       reduce using rule 127 (pop_op_art_n2 -> .)
    RBRACKET        reduce using rule 127 (pop_op_art_n2 -> .)

    pop_op_art_n2                  shift and go to state 183

state 148

    (105) factor_aux -> PLUS . cte
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    ID              shift and go to state 185
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    cte                            shift and go to state 184

state 149

    (106) factor_aux -> MINUS . cte
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    ID              shift and go to state 185
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    cte                            shift and go to state 186

state 150

    (98) term -> factor . pop_op_art_n1
    (99) term -> factor . pop_op_art_n1 TIMES push_op term
    (100) term -> factor . pop_op_art_n1 DIVIDE push_op term
    (126) pop_op_art_n1 -> .

    TIMES           reduce using rule 126 (pop_op_art_n1 -> .)
    DIVIDE          reduce using rule 126 (pop_op_art_n1 -> .)
    PLUS            reduce using rule 126 (pop_op_art_n1 -> .)
    MINUS           reduce using rule 126 (pop_op_art_n1 -> .)
    RELOP           reduce using rule 126 (pop_op_art_n1 -> .)
    OR              reduce using rule 126 (pop_op_art_n1 -> .)
    AND             reduce using rule 126 (pop_op_art_n1 -> .)
    COMMA           reduce using rule 126 (pop_op_art_n1 -> .)
    RPAREN          reduce using rule 126 (pop_op_art_n1 -> .)
    SEMICOLON       reduce using rule 126 (pop_op_art_n1 -> .)
    RBRACKET        reduce using rule 126 (pop_op_art_n1 -> .)

    pop_op_art_n1                  shift and go to state 187

state 151

    (102) factor -> factor_aux .

    TIMES           reduce using rule 102 (factor -> factor_aux .)
    DIVIDE          reduce using rule 102 (factor -> factor_aux .)
    PLUS            reduce using rule 102 (factor -> factor_aux .)
    MINUS           reduce using rule 102 (factor -> factor_aux .)
    RELOP           reduce using rule 102 (factor -> factor_aux .)
    OR              reduce using rule 102 (factor -> factor_aux .)
    AND             reduce using rule 102 (factor -> factor_aux .)
    COMMA           reduce using rule 102 (factor -> factor_aux .)
    RPAREN          reduce using rule 102 (factor -> factor_aux .)
    SEMICOLON       reduce using rule 102 (factor -> factor_aux .)
    RBRACKET        reduce using rule 102 (factor -> factor_aux .)


state 152

    (103) factor -> call .

    TIMES           reduce using rule 103 (factor -> call .)
    DIVIDE          reduce using rule 103 (factor -> call .)
    PLUS            reduce using rule 103 (factor -> call .)
    MINUS           reduce using rule 103 (factor -> call .)
    RELOP           reduce using rule 103 (factor -> call .)
    OR              reduce using rule 103 (factor -> call .)
    AND             reduce using rule 103 (factor -> call .)
    COMMA           reduce using rule 103 (factor -> call .)
    RPAREN          reduce using rule 103 (factor -> call .)
    SEMICOLON       reduce using rule 103 (factor -> call .)
    RBRACKET        reduce using rule 103 (factor -> call .)


state 153

    (104) factor_aux -> cte .

    TIMES           reduce using rule 104 (factor_aux -> cte .)
    DIVIDE          reduce using rule 104 (factor_aux -> cte .)
    PLUS            reduce using rule 104 (factor_aux -> cte .)
    MINUS           reduce using rule 104 (factor_aux -> cte .)
    RELOP           reduce using rule 104 (factor_aux -> cte .)
    OR              reduce using rule 104 (factor_aux -> cte .)
    AND             reduce using rule 104 (factor_aux -> cte .)
    COMMA           reduce using rule 104 (factor_aux -> cte .)
    RPAREN          reduce using rule 104 (factor_aux -> cte .)
    SEMICOLON       reduce using rule 104 (factor_aux -> cte .)
    RBRACKET        reduce using rule 104 (factor_aux -> cte .)


state 154

    (63) call -> ID . exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> ID . POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> ID . exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> ID . POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> ID . push_var
    (108) cte -> ID . var_aux
    (109) cte -> ID . push_var var_aux_2
    (152) exist_function -> .
    (123) push_var -> .
    (58) var_aux -> . POINT ID push_obj_var
    (59) var_aux -> . POINT ID var_aux_2

    POINT           shift and go to state 188
    LPAREN          reduce using rule 152 (exist_function -> .)
    LBRACKET        reduce using rule 123 (push_var -> .)
    TIMES           reduce using rule 123 (push_var -> .)
    DIVIDE          reduce using rule 123 (push_var -> .)
    PLUS            reduce using rule 123 (push_var -> .)
    MINUS           reduce using rule 123 (push_var -> .)
    RELOP           reduce using rule 123 (push_var -> .)
    OR              reduce using rule 123 (push_var -> .)
    AND             reduce using rule 123 (push_var -> .)
    COMMA           reduce using rule 123 (push_var -> .)
    RPAREN          reduce using rule 123 (push_var -> .)
    SEMICOLON       reduce using rule 123 (push_var -> .)
    RBRACKET        reduce using rule 123 (push_var -> .)

    exist_function                 shift and go to state 132
    push_var                       shift and go to state 189
    var_aux                        shift and go to state 190

state 155

    (110) cte -> CTEI . push_var
    (123) push_var -> .

    TIMES           reduce using rule 123 (push_var -> .)
    DIVIDE          reduce using rule 123 (push_var -> .)
    PLUS            reduce using rule 123 (push_var -> .)
    MINUS           reduce using rule 123 (push_var -> .)
    RELOP           reduce using rule 123 (push_var -> .)
    OR              reduce using rule 123 (push_var -> .)
    AND             reduce using rule 123 (push_var -> .)
    COMMA           reduce using rule 123 (push_var -> .)
    RPAREN          reduce using rule 123 (push_var -> .)
    SEMICOLON       reduce using rule 123 (push_var -> .)
    RBRACKET        reduce using rule 123 (push_var -> .)

    push_var                       shift and go to state 191

state 156

    (111) cte -> CTEF . push_var
    (123) push_var -> .

    TIMES           reduce using rule 123 (push_var -> .)
    DIVIDE          reduce using rule 123 (push_var -> .)
    PLUS            reduce using rule 123 (push_var -> .)
    MINUS           reduce using rule 123 (push_var -> .)
    RELOP           reduce using rule 123 (push_var -> .)
    OR              reduce using rule 123 (push_var -> .)
    AND             reduce using rule 123 (push_var -> .)
    COMMA           reduce using rule 123 (push_var -> .)
    RPAREN          reduce using rule 123 (push_var -> .)
    SEMICOLON       reduce using rule 123 (push_var -> .)
    RBRACKET        reduce using rule 123 (push_var -> .)

    push_var                       shift and go to state 192

state 157

    (112) cte -> CTECHAR . push_var
    (123) push_var -> .

    TIMES           reduce using rule 123 (push_var -> .)
    DIVIDE          reduce using rule 123 (push_var -> .)
    PLUS            reduce using rule 123 (push_var -> .)
    MINUS           reduce using rule 123 (push_var -> .)
    RELOP           reduce using rule 123 (push_var -> .)
    OR              reduce using rule 123 (push_var -> .)
    AND             reduce using rule 123 (push_var -> .)
    COMMA           reduce using rule 123 (push_var -> .)
    RPAREN          reduce using rule 123 (push_var -> .)
    SEMICOLON       reduce using rule 123 (push_var -> .)
    RBRACKET        reduce using rule 123 (push_var -> .)

    push_var                       shift and go to state 193

state 158

    (71) condition -> IF LPAREN exp . RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if

    RPAREN          shift and go to state 194


state 159

    (88) while -> WHILE while_jump LPAREN . exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 195
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 160

    (89) for -> FROM LPAREN assignation . RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    RPAREN          shift and go to state 196


state 161

    (22) vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET CTEI . RBRACKET add_matrix_variable

    RBRACKET        shift and go to state 197


state 162

    (35) functions_aux -> VOID ID add_function LPAREN params RPAREN insert_number_params . body
    (41) body -> . LBRACE start_function dec_vars statutes_aux RBRACE end_function
    (42) body -> . LBRACE start_function statutes_aux RBRACE end_function
    (43) body -> . LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (44) body -> . LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (45) body -> . LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function

    LBRACE          shift and go to state 126

    body                           shift and go to state 198

state 163

    (41) body -> LBRACE start_function . dec_vars statutes_aux RBRACE end_function
    (42) body -> LBRACE start_function . statutes_aux RBRACE end_function
    (43) body -> LBRACE start_function . statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (44) body -> LBRACE start_function . dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (45) body -> LBRACE start_function . RETURN ID return_function SEMICOLON RBRACE end_function
    (9) dec_vars -> . VAR dec_vars_aux
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    RETURN          shift and go to state 201
    VAR             shift and go to state 24
    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    dec_vars                       shift and go to state 199
    statutes_aux                   shift and go to state 200
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 164

    (39) params -> simple_type ID add_param .
    (40) params -> simple_type ID add_param . COMMA params

    RPAREN          reduce using rule 39 (params -> simple_type ID add_param .)
    COMMA           shift and go to state 202


state 165

    (38) functions_aux -> simple_type ID add_function LPAREN params RPAREN insert_number_params . body
    (41) body -> . LBRACE start_function dec_vars statutes_aux RBRACE end_function
    (42) body -> . LBRACE start_function statutes_aux RBRACE end_function
    (43) body -> . LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (44) body -> . LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (45) body -> . LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function

    LBRACE          shift and go to state 126

    body                           shift and go to state 203

state 166

    (63) call -> ID exist_function LPAREN . era_function RPAREN gosub_function
    (65) call -> ID exist_function LPAREN . push_paren era_function call_aux RPAREN pop_paren gosub_function
    (153) era_function -> .
    (131) push_paren -> .

    RPAREN          reduce using rule 153 (era_function -> .)
    LPAREN          reduce using rule 131 (push_paren -> .)
    PLUS            reduce using rule 131 (push_paren -> .)
    MINUS           reduce using rule 131 (push_paren -> .)
    ID              reduce using rule 131 (push_paren -> .)
    CTEI            reduce using rule 131 (push_paren -> .)
    CTEF            reduce using rule 131 (push_paren -> .)
    CTECHAR         reduce using rule 131 (push_paren -> .)

    era_function                   shift and go to state 204
    push_paren                     shift and go to state 205

state 167

    (64) call -> ID POINT ID . exist_method LPAREN era_method RPAREN gosub_method
    (66) call -> ID POINT ID . exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (162) exist_method -> .

    LPAREN          reduce using rule 162 (exist_method -> .)

    exist_method                   shift and go to state 206

state 168

    (55) assignation -> ID push_var EQUAL push_op . exp pop_op_assign
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 207
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 169

    (57) assignation -> ID push_var var_aux_2 EQUAL . push_op exp pop_op_assign
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 208

state 170

    (60) var_aux_2 -> LBRACKET access_array . exp verify_array_index RBRACKET var_aux_3
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 209
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 171

    (56) assignation -> ID var_aux EQUAL push_op . exp pop_op_assign
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 210
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 172

    (58) var_aux -> POINT ID push_obj_var .

    EQUAL           reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    COMMA           reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    RPAREN          reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    TIMES           reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    DIVIDE          reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    PLUS            reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    MINUS           reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    RELOP           reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    OR              reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    AND             reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    SEMICOLON       reduce using rule 58 (var_aux -> POINT ID push_obj_var .)
    RBRACKET        reduce using rule 58 (var_aux -> POINT ID push_obj_var .)


state 173

    (59) var_aux -> POINT ID var_aux_2 .

    EQUAL           reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    COMMA           reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    RPAREN          reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    TIMES           reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    DIVIDE          reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    PLUS            reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    MINUS           reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    RELOP           reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    OR              reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    AND             reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    SEMICOLON       reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)
    RBRACKET        reduce using rule 59 (var_aux -> POINT ID var_aux_2 .)


state 174

    (76) read -> READ LPAREN read_aux RPAREN . SEMICOLON generate_read

    SEMICOLON       shift and go to state 211


state 175

    (77) read_aux -> ID push_var .
    (78) read_aux -> ID push_var . COMMA generate_read read_aux
    (81) read_aux -> ID push_var . var_aux_2
    (82) read_aux -> ID push_var . var_aux_2 COMMA generate_read read_aux
    (60) var_aux_2 -> . LBRACKET access_array exp verify_array_index RBRACKET var_aux_3

    RPAREN          reduce using rule 77 (read_aux -> ID push_var .)
    COMMA           shift and go to state 212
    LBRACKET        shift and go to state 136

    var_aux_2                      shift and go to state 213

state 176

    (79) read_aux -> ID var_aux .
    (80) read_aux -> ID var_aux . COMMA generate_read read_aux

    RPAREN          reduce using rule 79 (read_aux -> ID var_aux .)
    COMMA           shift and go to state 214


state 177

    (101) factor -> LPAREN push_paren . exp RPAREN pop_paren
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 215
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 178

    (83) write -> WRITE LPAREN write_aux RPAREN . SEMICOLON generate_write

    SEMICOLON       shift and go to state 216


state 179

    (85) write_aux -> exp COMMA . generate_write write_aux
    (133) generate_write -> .

    CTESTRING       reduce using rule 133 (generate_write -> .)
    LPAREN          reduce using rule 133 (generate_write -> .)
    PLUS            reduce using rule 133 (generate_write -> .)
    MINUS           reduce using rule 133 (generate_write -> .)
    ID              reduce using rule 133 (generate_write -> .)
    CTEI            reduce using rule 133 (generate_write -> .)
    CTEF            reduce using rule 133 (generate_write -> .)
    CTECHAR         reduce using rule 133 (generate_write -> .)

    generate_write                 shift and go to state 217

state 180

    (86) write_aux -> CTESTRING save_string .
    (87) write_aux -> CTESTRING save_string . COMMA generate_write write_aux

    RPAREN          reduce using rule 86 (write_aux -> CTESTRING save_string .)
    COMMA           shift and go to state 218


state 181

    (90) exp -> l_exp pop_op_lop .
    (91) exp -> l_exp pop_op_lop . OR push_op exp
    (92) exp -> l_exp pop_op_lop . AND push_op exp

    COMMA           reduce using rule 90 (exp -> l_exp pop_op_lop .)
    RPAREN          reduce using rule 90 (exp -> l_exp pop_op_lop .)
    SEMICOLON       reduce using rule 90 (exp -> l_exp pop_op_lop .)
    RBRACKET        reduce using rule 90 (exp -> l_exp pop_op_lop .)
    OR              shift and go to state 219
    AND             shift and go to state 220


state 182

    (94) l_exp -> a_exp RELOP . push_op a_exp pop_op_relop
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 221

state 183

    (95) a_exp -> term pop_op_art_n2 .
    (96) a_exp -> term pop_op_art_n2 . PLUS push_op a_exp
    (97) a_exp -> term pop_op_art_n2 . MINUS push_op a_exp

    RELOP           reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    OR              reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    AND             reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    COMMA           reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    RPAREN          reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    SEMICOLON       reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    RBRACKET        reduce using rule 95 (a_exp -> term pop_op_art_n2 .)
    PLUS            shift and go to state 222
    MINUS           shift and go to state 223


state 184

    (105) factor_aux -> PLUS cte .

    TIMES           reduce using rule 105 (factor_aux -> PLUS cte .)
    DIVIDE          reduce using rule 105 (factor_aux -> PLUS cte .)
    PLUS            reduce using rule 105 (factor_aux -> PLUS cte .)
    MINUS           reduce using rule 105 (factor_aux -> PLUS cte .)
    RELOP           reduce using rule 105 (factor_aux -> PLUS cte .)
    OR              reduce using rule 105 (factor_aux -> PLUS cte .)
    AND             reduce using rule 105 (factor_aux -> PLUS cte .)
    COMMA           reduce using rule 105 (factor_aux -> PLUS cte .)
    RPAREN          reduce using rule 105 (factor_aux -> PLUS cte .)
    SEMICOLON       reduce using rule 105 (factor_aux -> PLUS cte .)
    RBRACKET        reduce using rule 105 (factor_aux -> PLUS cte .)


state 185

    (107) cte -> ID . push_var
    (108) cte -> ID . var_aux
    (109) cte -> ID . push_var var_aux_2
    (123) push_var -> .
    (58) var_aux -> . POINT ID push_obj_var
    (59) var_aux -> . POINT ID var_aux_2

    LBRACKET        reduce using rule 123 (push_var -> .)
    TIMES           reduce using rule 123 (push_var -> .)
    DIVIDE          reduce using rule 123 (push_var -> .)
    PLUS            reduce using rule 123 (push_var -> .)
    MINUS           reduce using rule 123 (push_var -> .)
    RELOP           reduce using rule 123 (push_var -> .)
    OR              reduce using rule 123 (push_var -> .)
    AND             reduce using rule 123 (push_var -> .)
    COMMA           reduce using rule 123 (push_var -> .)
    RPAREN          reduce using rule 123 (push_var -> .)
    SEMICOLON       reduce using rule 123 (push_var -> .)
    RBRACKET        reduce using rule 123 (push_var -> .)
    POINT           shift and go to state 116

    push_var                       shift and go to state 189
    var_aux                        shift and go to state 190

state 186

    (106) factor_aux -> MINUS cte .

    TIMES           reduce using rule 106 (factor_aux -> MINUS cte .)
    DIVIDE          reduce using rule 106 (factor_aux -> MINUS cte .)
    PLUS            reduce using rule 106 (factor_aux -> MINUS cte .)
    MINUS           reduce using rule 106 (factor_aux -> MINUS cte .)
    RELOP           reduce using rule 106 (factor_aux -> MINUS cte .)
    OR              reduce using rule 106 (factor_aux -> MINUS cte .)
    AND             reduce using rule 106 (factor_aux -> MINUS cte .)
    COMMA           reduce using rule 106 (factor_aux -> MINUS cte .)
    RPAREN          reduce using rule 106 (factor_aux -> MINUS cte .)
    SEMICOLON       reduce using rule 106 (factor_aux -> MINUS cte .)
    RBRACKET        reduce using rule 106 (factor_aux -> MINUS cte .)


state 187

    (98) term -> factor pop_op_art_n1 .
    (99) term -> factor pop_op_art_n1 . TIMES push_op term
    (100) term -> factor pop_op_art_n1 . DIVIDE push_op term

    PLUS            reduce using rule 98 (term -> factor pop_op_art_n1 .)
    MINUS           reduce using rule 98 (term -> factor pop_op_art_n1 .)
    RELOP           reduce using rule 98 (term -> factor pop_op_art_n1 .)
    OR              reduce using rule 98 (term -> factor pop_op_art_n1 .)
    AND             reduce using rule 98 (term -> factor pop_op_art_n1 .)
    COMMA           reduce using rule 98 (term -> factor pop_op_art_n1 .)
    RPAREN          reduce using rule 98 (term -> factor pop_op_art_n1 .)
    SEMICOLON       reduce using rule 98 (term -> factor pop_op_art_n1 .)
    RBRACKET        reduce using rule 98 (term -> factor pop_op_art_n1 .)
    TIMES           shift and go to state 224
    DIVIDE          shift and go to state 225


state 188

    (64) call -> ID POINT . ID exist_method LPAREN era_method RPAREN gosub_method
    (66) call -> ID POINT . ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (58) var_aux -> POINT . ID push_obj_var
    (59) var_aux -> POINT . ID var_aux_2

    ID              shift and go to state 226


state 189

    (107) cte -> ID push_var .
    (109) cte -> ID push_var . var_aux_2
    (60) var_aux_2 -> . LBRACKET access_array exp verify_array_index RBRACKET var_aux_3

    TIMES           reduce using rule 107 (cte -> ID push_var .)
    DIVIDE          reduce using rule 107 (cte -> ID push_var .)
    PLUS            reduce using rule 107 (cte -> ID push_var .)
    MINUS           reduce using rule 107 (cte -> ID push_var .)
    RELOP           reduce using rule 107 (cte -> ID push_var .)
    OR              reduce using rule 107 (cte -> ID push_var .)
    AND             reduce using rule 107 (cte -> ID push_var .)
    COMMA           reduce using rule 107 (cte -> ID push_var .)
    RPAREN          reduce using rule 107 (cte -> ID push_var .)
    SEMICOLON       reduce using rule 107 (cte -> ID push_var .)
    RBRACKET        reduce using rule 107 (cte -> ID push_var .)
    LBRACKET        shift and go to state 136

    var_aux_2                      shift and go to state 227

state 190

    (108) cte -> ID var_aux .

    TIMES           reduce using rule 108 (cte -> ID var_aux .)
    DIVIDE          reduce using rule 108 (cte -> ID var_aux .)
    PLUS            reduce using rule 108 (cte -> ID var_aux .)
    MINUS           reduce using rule 108 (cte -> ID var_aux .)
    RELOP           reduce using rule 108 (cte -> ID var_aux .)
    OR              reduce using rule 108 (cte -> ID var_aux .)
    AND             reduce using rule 108 (cte -> ID var_aux .)
    COMMA           reduce using rule 108 (cte -> ID var_aux .)
    RPAREN          reduce using rule 108 (cte -> ID var_aux .)
    SEMICOLON       reduce using rule 108 (cte -> ID var_aux .)
    RBRACKET        reduce using rule 108 (cte -> ID var_aux .)


state 191

    (110) cte -> CTEI push_var .

    TIMES           reduce using rule 110 (cte -> CTEI push_var .)
    DIVIDE          reduce using rule 110 (cte -> CTEI push_var .)
    PLUS            reduce using rule 110 (cte -> CTEI push_var .)
    MINUS           reduce using rule 110 (cte -> CTEI push_var .)
    RELOP           reduce using rule 110 (cte -> CTEI push_var .)
    OR              reduce using rule 110 (cte -> CTEI push_var .)
    AND             reduce using rule 110 (cte -> CTEI push_var .)
    COMMA           reduce using rule 110 (cte -> CTEI push_var .)
    RPAREN          reduce using rule 110 (cte -> CTEI push_var .)
    SEMICOLON       reduce using rule 110 (cte -> CTEI push_var .)
    RBRACKET        reduce using rule 110 (cte -> CTEI push_var .)


state 192

    (111) cte -> CTEF push_var .

    TIMES           reduce using rule 111 (cte -> CTEF push_var .)
    DIVIDE          reduce using rule 111 (cte -> CTEF push_var .)
    PLUS            reduce using rule 111 (cte -> CTEF push_var .)
    MINUS           reduce using rule 111 (cte -> CTEF push_var .)
    RELOP           reduce using rule 111 (cte -> CTEF push_var .)
    OR              reduce using rule 111 (cte -> CTEF push_var .)
    AND             reduce using rule 111 (cte -> CTEF push_var .)
    COMMA           reduce using rule 111 (cte -> CTEF push_var .)
    RPAREN          reduce using rule 111 (cte -> CTEF push_var .)
    SEMICOLON       reduce using rule 111 (cte -> CTEF push_var .)
    RBRACKET        reduce using rule 111 (cte -> CTEF push_var .)


state 193

    (112) cte -> CTECHAR push_var .

    TIMES           reduce using rule 112 (cte -> CTECHAR push_var .)
    DIVIDE          reduce using rule 112 (cte -> CTECHAR push_var .)
    PLUS            reduce using rule 112 (cte -> CTECHAR push_var .)
    MINUS           reduce using rule 112 (cte -> CTECHAR push_var .)
    RELOP           reduce using rule 112 (cte -> CTECHAR push_var .)
    OR              reduce using rule 112 (cte -> CTECHAR push_var .)
    AND             reduce using rule 112 (cte -> CTECHAR push_var .)
    COMMA           reduce using rule 112 (cte -> CTECHAR push_var .)
    RPAREN          reduce using rule 112 (cte -> CTECHAR push_var .)
    SEMICOLON       reduce using rule 112 (cte -> CTECHAR push_var .)
    RBRACKET        reduce using rule 112 (cte -> CTECHAR push_var .)


state 194

    (71) condition -> IF LPAREN exp RPAREN . if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (136) if_condition -> .

    THEN            reduce using rule 136 (if_condition -> .)

    if_condition                   shift and go to state 228

state 195

    (88) while -> WHILE while_jump LPAREN exp . RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while

    RPAREN          shift and go to state 229


state 196

    (89) for -> FROM LPAREN assignation RPAREN . UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    UNTIL           shift and go to state 230


state 197

    (22) vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET . add_matrix_variable
    (118) add_matrix_variable -> .

    COMMA           reduce using rule 118 (add_matrix_variable -> .)
    SEMICOLON       reduce using rule 118 (add_matrix_variable -> .)

    add_matrix_variable            shift and go to state 231

state 198

    (35) functions_aux -> VOID ID add_function LPAREN params RPAREN insert_number_params body .

    FUNCT           reduce using rule 35 (functions_aux -> VOID ID add_function LPAREN params RPAREN insert_number_params body .)
    RBRACE          reduce using rule 35 (functions_aux -> VOID ID add_function LPAREN params RPAREN insert_number_params body .)
    INIT            reduce using rule 35 (functions_aux -> VOID ID add_function LPAREN params RPAREN insert_number_params body .)


state 199

    (41) body -> LBRACE start_function dec_vars . statutes_aux RBRACE end_function
    (44) body -> LBRACE start_function dec_vars . statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 232
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 200

    (42) body -> LBRACE start_function statutes_aux . RBRACE end_function
    (43) body -> LBRACE start_function statutes_aux . RETURN ID return_function SEMICOLON RBRACE end_function

    RBRACE          shift and go to state 233
    RETURN          shift and go to state 234


state 201

    (45) body -> LBRACE start_function RETURN . ID return_function SEMICOLON RBRACE end_function

    ID              shift and go to state 235


state 202

    (40) params -> simple_type ID add_param COMMA . params
    (39) params -> . simple_type ID add_param
    (40) params -> . simple_type ID add_param COMMA params
    (14) simple_type -> . INT
    (15) simple_type -> . FLOAT
    (16) simple_type -> . CHAR

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    CHAR            shift and go to state 41

    simple_type                    shift and go to state 105
    params                         shift and go to state 236

state 203

    (38) functions_aux -> simple_type ID add_function LPAREN params RPAREN insert_number_params body .

    FUNCT           reduce using rule 38 (functions_aux -> simple_type ID add_function LPAREN params RPAREN insert_number_params body .)
    RBRACE          reduce using rule 38 (functions_aux -> simple_type ID add_function LPAREN params RPAREN insert_number_params body .)
    INIT            reduce using rule 38 (functions_aux -> simple_type ID add_function LPAREN params RPAREN insert_number_params body .)


state 204

    (63) call -> ID exist_function LPAREN era_function . RPAREN gosub_function

    RPAREN          shift and go to state 237


state 205

    (65) call -> ID exist_function LPAREN push_paren . era_function call_aux RPAREN pop_paren gosub_function
    (153) era_function -> .

    LPAREN          reduce using rule 153 (era_function -> .)
    PLUS            reduce using rule 153 (era_function -> .)
    MINUS           reduce using rule 153 (era_function -> .)
    ID              reduce using rule 153 (era_function -> .)
    CTEI            reduce using rule 153 (era_function -> .)
    CTEF            reduce using rule 153 (era_function -> .)
    CTECHAR         reduce using rule 153 (era_function -> .)

    era_function                   shift and go to state 238

state 206

    (64) call -> ID POINT ID exist_method . LPAREN era_method RPAREN gosub_method
    (66) call -> ID POINT ID exist_method . LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method

    LPAREN          shift and go to state 239


state 207

    (55) assignation -> ID push_var EQUAL push_op exp . pop_op_assign
    (130) pop_op_assign -> .

    SEMICOLON       reduce using rule 130 (pop_op_assign -> .)
    RPAREN          reduce using rule 130 (pop_op_assign -> .)

    pop_op_assign                  shift and go to state 240

state 208

    (57) assignation -> ID push_var var_aux_2 EQUAL push_op . exp pop_op_assign
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 241
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 209

    (60) var_aux_2 -> LBRACKET access_array exp . verify_array_index RBRACKET var_aux_3
    (157) verify_array_index -> .

    RBRACKET        reduce using rule 157 (verify_array_index -> .)

    verify_array_index             shift and go to state 242

state 210

    (56) assignation -> ID var_aux EQUAL push_op exp . pop_op_assign
    (130) pop_op_assign -> .

    SEMICOLON       reduce using rule 130 (pop_op_assign -> .)
    RPAREN          reduce using rule 130 (pop_op_assign -> .)

    pop_op_assign                  shift and go to state 243

state 211

    (76) read -> READ LPAREN read_aux RPAREN SEMICOLON . generate_read
    (135) generate_read -> .

    CALL            reduce using rule 135 (generate_read -> .)
    ID              reduce using rule 135 (generate_read -> .)
    READ            reduce using rule 135 (generate_read -> .)
    WRITE           reduce using rule 135 (generate_read -> .)
    IF              reduce using rule 135 (generate_read -> .)
    WHILE           reduce using rule 135 (generate_read -> .)
    FROM            reduce using rule 135 (generate_read -> .)
    RBRACE          reduce using rule 135 (generate_read -> .)
    RETURN          reduce using rule 135 (generate_read -> .)

    generate_read                  shift and go to state 244

state 212

    (78) read_aux -> ID push_var COMMA . generate_read read_aux
    (135) generate_read -> .

    ID              reduce using rule 135 (generate_read -> .)

    generate_read                  shift and go to state 245

state 213

    (81) read_aux -> ID push_var var_aux_2 .
    (82) read_aux -> ID push_var var_aux_2 . COMMA generate_read read_aux

    RPAREN          reduce using rule 81 (read_aux -> ID push_var var_aux_2 .)
    COMMA           shift and go to state 246


state 214

    (80) read_aux -> ID var_aux COMMA . generate_read read_aux
    (135) generate_read -> .

    ID              reduce using rule 135 (generate_read -> .)

    generate_read                  shift and go to state 247

state 215

    (101) factor -> LPAREN push_paren exp . RPAREN pop_paren

    RPAREN          shift and go to state 248


state 216

    (83) write -> WRITE LPAREN write_aux RPAREN SEMICOLON . generate_write
    (133) generate_write -> .

    CALL            reduce using rule 133 (generate_write -> .)
    ID              reduce using rule 133 (generate_write -> .)
    READ            reduce using rule 133 (generate_write -> .)
    WRITE           reduce using rule 133 (generate_write -> .)
    IF              reduce using rule 133 (generate_write -> .)
    WHILE           reduce using rule 133 (generate_write -> .)
    FROM            reduce using rule 133 (generate_write -> .)
    RBRACE          reduce using rule 133 (generate_write -> .)
    RETURN          reduce using rule 133 (generate_write -> .)

    generate_write                 shift and go to state 249

state 217

    (85) write_aux -> exp COMMA generate_write . write_aux
    (84) write_aux -> . exp
    (85) write_aux -> . exp COMMA generate_write write_aux
    (86) write_aux -> . CTESTRING save_string
    (87) write_aux -> . CTESTRING save_string COMMA generate_write write_aux
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    CTESTRING       shift and go to state 144
    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 143
    write_aux                      shift and go to state 250
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 218

    (87) write_aux -> CTESTRING save_string COMMA . generate_write write_aux
    (133) generate_write -> .

    CTESTRING       reduce using rule 133 (generate_write -> .)
    LPAREN          reduce using rule 133 (generate_write -> .)
    PLUS            reduce using rule 133 (generate_write -> .)
    MINUS           reduce using rule 133 (generate_write -> .)
    ID              reduce using rule 133 (generate_write -> .)
    CTEI            reduce using rule 133 (generate_write -> .)
    CTEF            reduce using rule 133 (generate_write -> .)
    CTECHAR         reduce using rule 133 (generate_write -> .)

    generate_write                 shift and go to state 251

state 219

    (91) exp -> l_exp pop_op_lop OR . push_op exp
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 252

state 220

    (92) exp -> l_exp pop_op_lop AND . push_op exp
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 253

state 221

    (94) l_exp -> a_exp RELOP push_op . a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    a_exp                          shift and go to state 254
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 222

    (96) a_exp -> term pop_op_art_n2 PLUS . push_op a_exp
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 255

state 223

    (97) a_exp -> term pop_op_art_n2 MINUS . push_op a_exp
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 256

state 224

    (99) term -> factor pop_op_art_n1 TIMES . push_op term
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 257

state 225

    (100) term -> factor pop_op_art_n1 DIVIDE . push_op term
    (124) push_op -> .

    LPAREN          reduce using rule 124 (push_op -> .)
    PLUS            reduce using rule 124 (push_op -> .)
    MINUS           reduce using rule 124 (push_op -> .)
    ID              reduce using rule 124 (push_op -> .)
    CTEI            reduce using rule 124 (push_op -> .)
    CTEF            reduce using rule 124 (push_op -> .)
    CTECHAR         reduce using rule 124 (push_op -> .)

    push_op                        shift and go to state 258

state 226

    (64) call -> ID POINT ID . exist_method LPAREN era_method RPAREN gosub_method
    (66) call -> ID POINT ID . exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (58) var_aux -> POINT ID . push_obj_var
    (59) var_aux -> POINT ID . var_aux_2
    (162) exist_method -> .
    (125) push_obj_var -> .
    (60) var_aux_2 -> . LBRACKET access_array exp verify_array_index RBRACKET var_aux_3

    LPAREN          reduce using rule 162 (exist_method -> .)
    TIMES           reduce using rule 125 (push_obj_var -> .)
    DIVIDE          reduce using rule 125 (push_obj_var -> .)
    PLUS            reduce using rule 125 (push_obj_var -> .)
    MINUS           reduce using rule 125 (push_obj_var -> .)
    RELOP           reduce using rule 125 (push_obj_var -> .)
    OR              reduce using rule 125 (push_obj_var -> .)
    AND             reduce using rule 125 (push_obj_var -> .)
    COMMA           reduce using rule 125 (push_obj_var -> .)
    RPAREN          reduce using rule 125 (push_obj_var -> .)
    SEMICOLON       reduce using rule 125 (push_obj_var -> .)
    RBRACKET        reduce using rule 125 (push_obj_var -> .)
    LBRACKET        shift and go to state 136

    exist_method                   shift and go to state 206
    push_obj_var                   shift and go to state 172
    var_aux_2                      shift and go to state 173

state 227

    (109) cte -> ID push_var var_aux_2 .

    TIMES           reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    DIVIDE          reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    PLUS            reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    MINUS           reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    RELOP           reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    OR              reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    AND             reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    COMMA           reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    RPAREN          reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    SEMICOLON       reduce using rule 109 (cte -> ID push_var var_aux_2 .)
    RBRACKET        reduce using rule 109 (cte -> ID push_var var_aux_2 .)


state 228

    (71) condition -> IF LPAREN exp RPAREN if_condition . THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if

    THEN            shift and go to state 259


state 229

    (88) while -> WHILE while_jump LPAREN exp RPAREN . while_condition DO LBRACE statutes_aux RBRACE end_while
    (142) while_condition -> .

    DO              reduce using rule 142 (while_condition -> .)

    while_condition                shift and go to state 260

state 230

    (89) for -> FROM LPAREN assignation RPAREN UNTIL . for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for
    (144) for_jump -> .

    LPAREN          reduce using rule 144 (for_jump -> .)

    for_jump                       shift and go to state 261

state 231

    (22) vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable .

    COMMA           reduce using rule 22 (vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable .)
    SEMICOLON       reduce using rule 22 (vars_simple_type_aux -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET add_matrix_variable .)


state 232

    (41) body -> LBRACE start_function dec_vars statutes_aux . RBRACE end_function
    (44) body -> LBRACE start_function dec_vars statutes_aux . RETURN ID return_function SEMICOLON RBRACE end_function

    RBRACE          shift and go to state 262
    RETURN          shift and go to state 263


state 233

    (42) body -> LBRACE start_function statutes_aux RBRACE . end_function
    (151) end_function -> .

    FUNCT           reduce using rule 151 (end_function -> .)
    RBRACE          reduce using rule 151 (end_function -> .)
    INIT            reduce using rule 151 (end_function -> .)

    end_function                   shift and go to state 264

state 234

    (43) body -> LBRACE start_function statutes_aux RETURN . ID return_function SEMICOLON RBRACE end_function

    ID              shift and go to state 265


state 235

    (45) body -> LBRACE start_function RETURN ID . return_function SEMICOLON RBRACE end_function
    (150) return_function -> .

    SEMICOLON       reduce using rule 150 (return_function -> .)

    return_function                shift and go to state 266

state 236

    (40) params -> simple_type ID add_param COMMA params .

    RPAREN          reduce using rule 40 (params -> simple_type ID add_param COMMA params .)


state 237

    (63) call -> ID exist_function LPAREN era_function RPAREN . gosub_function
    (155) gosub_function -> .

    SEMICOLON       reduce using rule 155 (gosub_function -> .)
    TIMES           reduce using rule 155 (gosub_function -> .)
    DIVIDE          reduce using rule 155 (gosub_function -> .)
    PLUS            reduce using rule 155 (gosub_function -> .)
    MINUS           reduce using rule 155 (gosub_function -> .)
    RELOP           reduce using rule 155 (gosub_function -> .)
    OR              reduce using rule 155 (gosub_function -> .)
    AND             reduce using rule 155 (gosub_function -> .)
    COMMA           reduce using rule 155 (gosub_function -> .)
    RPAREN          reduce using rule 155 (gosub_function -> .)
    RBRACKET        reduce using rule 155 (gosub_function -> .)

    gosub_function                 shift and go to state 267

state 238

    (65) call -> ID exist_function LPAREN push_paren era_function . call_aux RPAREN pop_paren gosub_function
    (67) call_aux -> . exp arg_function
    (68) call_aux -> . exp arg_function COMMA call_aux
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    call_aux                       shift and go to state 268
    exp                            shift and go to state 269
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 239

    (64) call -> ID POINT ID exist_method LPAREN . era_method RPAREN gosub_method
    (66) call -> ID POINT ID exist_method LPAREN . push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (163) era_method -> .
    (131) push_paren -> .

    RPAREN          reduce using rule 163 (era_method -> .)
    LPAREN          reduce using rule 131 (push_paren -> .)
    PLUS            reduce using rule 131 (push_paren -> .)
    MINUS           reduce using rule 131 (push_paren -> .)
    ID              reduce using rule 131 (push_paren -> .)
    CTEI            reduce using rule 131 (push_paren -> .)
    CTEF            reduce using rule 131 (push_paren -> .)
    CTECHAR         reduce using rule 131 (push_paren -> .)

    era_method                     shift and go to state 270
    push_paren                     shift and go to state 271

state 240

    (55) assignation -> ID push_var EQUAL push_op exp pop_op_assign .

    SEMICOLON       reduce using rule 55 (assignation -> ID push_var EQUAL push_op exp pop_op_assign .)
    RPAREN          reduce using rule 55 (assignation -> ID push_var EQUAL push_op exp pop_op_assign .)


state 241

    (57) assignation -> ID push_var var_aux_2 EQUAL push_op exp . pop_op_assign
    (130) pop_op_assign -> .

    SEMICOLON       reduce using rule 130 (pop_op_assign -> .)
    RPAREN          reduce using rule 130 (pop_op_assign -> .)

    pop_op_assign                  shift and go to state 272

state 242

    (60) var_aux_2 -> LBRACKET access_array exp verify_array_index . RBRACKET var_aux_3

    RBRACKET        shift and go to state 273


state 243

    (56) assignation -> ID var_aux EQUAL push_op exp pop_op_assign .

    SEMICOLON       reduce using rule 56 (assignation -> ID var_aux EQUAL push_op exp pop_op_assign .)
    RPAREN          reduce using rule 56 (assignation -> ID var_aux EQUAL push_op exp pop_op_assign .)


state 244

    (76) read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .

    CALL            reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    ID              reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    READ            reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    WRITE           reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    IF              reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    WHILE           reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    FROM            reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    RBRACE          reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)
    RETURN          reduce using rule 76 (read -> READ LPAREN read_aux RPAREN SEMICOLON generate_read .)


state 245

    (78) read_aux -> ID push_var COMMA generate_read . read_aux
    (77) read_aux -> . ID push_var
    (78) read_aux -> . ID push_var COMMA generate_read read_aux
    (79) read_aux -> . ID var_aux
    (80) read_aux -> . ID var_aux COMMA generate_read read_aux
    (81) read_aux -> . ID push_var var_aux_2
    (82) read_aux -> . ID push_var var_aux_2 COMMA generate_read read_aux

    ID              shift and go to state 140

    read_aux                       shift and go to state 274

state 246

    (82) read_aux -> ID push_var var_aux_2 COMMA . generate_read read_aux
    (135) generate_read -> .

    ID              reduce using rule 135 (generate_read -> .)

    generate_read                  shift and go to state 275

state 247

    (80) read_aux -> ID var_aux COMMA generate_read . read_aux
    (77) read_aux -> . ID push_var
    (78) read_aux -> . ID push_var COMMA generate_read read_aux
    (79) read_aux -> . ID var_aux
    (80) read_aux -> . ID var_aux COMMA generate_read read_aux
    (81) read_aux -> . ID push_var var_aux_2
    (82) read_aux -> . ID push_var var_aux_2 COMMA generate_read read_aux

    ID              shift and go to state 140

    read_aux                       shift and go to state 276

state 248

    (101) factor -> LPAREN push_paren exp RPAREN . pop_paren
    (132) pop_paren -> .

    TIMES           reduce using rule 132 (pop_paren -> .)
    DIVIDE          reduce using rule 132 (pop_paren -> .)
    PLUS            reduce using rule 132 (pop_paren -> .)
    MINUS           reduce using rule 132 (pop_paren -> .)
    RELOP           reduce using rule 132 (pop_paren -> .)
    OR              reduce using rule 132 (pop_paren -> .)
    AND             reduce using rule 132 (pop_paren -> .)
    COMMA           reduce using rule 132 (pop_paren -> .)
    RPAREN          reduce using rule 132 (pop_paren -> .)
    SEMICOLON       reduce using rule 132 (pop_paren -> .)
    RBRACKET        reduce using rule 132 (pop_paren -> .)

    pop_paren                      shift and go to state 277

state 249

    (83) write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .

    CALL            reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    ID              reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    READ            reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    WRITE           reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    IF              reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    WHILE           reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    FROM            reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    RBRACE          reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)
    RETURN          reduce using rule 83 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON generate_write .)


state 250

    (85) write_aux -> exp COMMA generate_write write_aux .

    RPAREN          reduce using rule 85 (write_aux -> exp COMMA generate_write write_aux .)


state 251

    (87) write_aux -> CTESTRING save_string COMMA generate_write . write_aux
    (84) write_aux -> . exp
    (85) write_aux -> . exp COMMA generate_write write_aux
    (86) write_aux -> . CTESTRING save_string
    (87) write_aux -> . CTESTRING save_string COMMA generate_write write_aux
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    CTESTRING       shift and go to state 144
    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    write_aux                      shift and go to state 278
    exp                            shift and go to state 143
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 252

    (91) exp -> l_exp pop_op_lop OR push_op . exp
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    l_exp                          shift and go to state 145
    exp                            shift and go to state 279
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 253

    (92) exp -> l_exp pop_op_lop AND push_op . exp
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    l_exp                          shift and go to state 145
    exp                            shift and go to state 280
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 254

    (94) l_exp -> a_exp RELOP push_op a_exp . pop_op_relop
    (128) pop_op_relop -> .

    OR              reduce using rule 128 (pop_op_relop -> .)
    AND             reduce using rule 128 (pop_op_relop -> .)
    COMMA           reduce using rule 128 (pop_op_relop -> .)
    RPAREN          reduce using rule 128 (pop_op_relop -> .)
    SEMICOLON       reduce using rule 128 (pop_op_relop -> .)
    RBRACKET        reduce using rule 128 (pop_op_relop -> .)

    pop_op_relop                   shift and go to state 281

state 255

    (96) a_exp -> term pop_op_art_n2 PLUS push_op . a_exp
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    term                           shift and go to state 147
    a_exp                          shift and go to state 282
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 256

    (97) a_exp -> term pop_op_art_n2 MINUS push_op . a_exp
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    term                           shift and go to state 147
    a_exp                          shift and go to state 283
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 257

    (99) term -> factor pop_op_art_n1 TIMES push_op . term
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    factor                         shift and go to state 150
    term                           shift and go to state 284
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 258

    (100) term -> factor pop_op_art_n1 DIVIDE push_op . term
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    factor                         shift and go to state 150
    term                           shift and go to state 285
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 259

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN . LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if

    LBRACE          shift and go to state 286


state 260

    (88) while -> WHILE while_jump LPAREN exp RPAREN while_condition . DO LBRACE statutes_aux RBRACE end_while

    DO              shift and go to state 287


state 261

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump . LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    LPAREN          shift and go to state 288


state 262

    (41) body -> LBRACE start_function dec_vars statutes_aux RBRACE . end_function
    (151) end_function -> .

    FUNCT           reduce using rule 151 (end_function -> .)
    RBRACE          reduce using rule 151 (end_function -> .)
    INIT            reduce using rule 151 (end_function -> .)

    end_function                   shift and go to state 289

state 263

    (44) body -> LBRACE start_function dec_vars statutes_aux RETURN . ID return_function SEMICOLON RBRACE end_function

    ID              shift and go to state 290


state 264

    (42) body -> LBRACE start_function statutes_aux RBRACE end_function .

    FUNCT           reduce using rule 42 (body -> LBRACE start_function statutes_aux RBRACE end_function .)
    RBRACE          reduce using rule 42 (body -> LBRACE start_function statutes_aux RBRACE end_function .)
    INIT            reduce using rule 42 (body -> LBRACE start_function statutes_aux RBRACE end_function .)


state 265

    (43) body -> LBRACE start_function statutes_aux RETURN ID . return_function SEMICOLON RBRACE end_function
    (150) return_function -> .

    SEMICOLON       reduce using rule 150 (return_function -> .)

    return_function                shift and go to state 291

state 266

    (45) body -> LBRACE start_function RETURN ID return_function . SEMICOLON RBRACE end_function

    SEMICOLON       shift and go to state 292


state 267

    (63) call -> ID exist_function LPAREN era_function RPAREN gosub_function .

    SEMICOLON       reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    TIMES           reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    DIVIDE          reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    PLUS            reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    MINUS           reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    RELOP           reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    OR              reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    AND             reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    COMMA           reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    RPAREN          reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)
    RBRACKET        reduce using rule 63 (call -> ID exist_function LPAREN era_function RPAREN gosub_function .)


state 268

    (65) call -> ID exist_function LPAREN push_paren era_function call_aux . RPAREN pop_paren gosub_function

    RPAREN          shift and go to state 293


state 269

    (67) call_aux -> exp . arg_function
    (68) call_aux -> exp . arg_function COMMA call_aux
    (154) arg_function -> .

    COMMA           reduce using rule 154 (arg_function -> .)
    RPAREN          reduce using rule 154 (arg_function -> .)

    arg_function                   shift and go to state 294

state 270

    (64) call -> ID POINT ID exist_method LPAREN era_method . RPAREN gosub_method

    RPAREN          shift and go to state 295


state 271

    (66) call -> ID POINT ID exist_method LPAREN push_paren . era_method call_aux_2 RPAREN pop_paren gosub_method
    (163) era_method -> .

    LPAREN          reduce using rule 163 (era_method -> .)
    PLUS            reduce using rule 163 (era_method -> .)
    MINUS           reduce using rule 163 (era_method -> .)
    ID              reduce using rule 163 (era_method -> .)
    CTEI            reduce using rule 163 (era_method -> .)
    CTEF            reduce using rule 163 (era_method -> .)
    CTECHAR         reduce using rule 163 (era_method -> .)

    era_method                     shift and go to state 296

state 272

    (57) assignation -> ID push_var var_aux_2 EQUAL push_op exp pop_op_assign .

    SEMICOLON       reduce using rule 57 (assignation -> ID push_var var_aux_2 EQUAL push_op exp pop_op_assign .)
    RPAREN          reduce using rule 57 (assignation -> ID push_var var_aux_2 EQUAL push_op exp pop_op_assign .)


state 273

    (60) var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET . var_aux_3
    (61) var_aux_3 -> . LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix
    (62) var_aux_3 -> . end_array
    (158) end_array -> .

    LBRACKET        shift and go to state 297
    EQUAL           reduce using rule 158 (end_array -> .)
    COMMA           reduce using rule 158 (end_array -> .)
    RPAREN          reduce using rule 158 (end_array -> .)
    TIMES           reduce using rule 158 (end_array -> .)
    DIVIDE          reduce using rule 158 (end_array -> .)
    PLUS            reduce using rule 158 (end_array -> .)
    MINUS           reduce using rule 158 (end_array -> .)
    RELOP           reduce using rule 158 (end_array -> .)
    OR              reduce using rule 158 (end_array -> .)
    AND             reduce using rule 158 (end_array -> .)
    SEMICOLON       reduce using rule 158 (end_array -> .)
    RBRACKET        reduce using rule 158 (end_array -> .)

    var_aux_3                      shift and go to state 298
    end_array                      shift and go to state 299

state 274

    (78) read_aux -> ID push_var COMMA generate_read read_aux .

    RPAREN          reduce using rule 78 (read_aux -> ID push_var COMMA generate_read read_aux .)


state 275

    (82) read_aux -> ID push_var var_aux_2 COMMA generate_read . read_aux
    (77) read_aux -> . ID push_var
    (78) read_aux -> . ID push_var COMMA generate_read read_aux
    (79) read_aux -> . ID var_aux
    (80) read_aux -> . ID var_aux COMMA generate_read read_aux
    (81) read_aux -> . ID push_var var_aux_2
    (82) read_aux -> . ID push_var var_aux_2 COMMA generate_read read_aux

    ID              shift and go to state 140

    read_aux                       shift and go to state 300

state 276

    (80) read_aux -> ID var_aux COMMA generate_read read_aux .

    RPAREN          reduce using rule 80 (read_aux -> ID var_aux COMMA generate_read read_aux .)


state 277

    (101) factor -> LPAREN push_paren exp RPAREN pop_paren .

    TIMES           reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    DIVIDE          reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    PLUS            reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    MINUS           reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    RELOP           reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    OR              reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    AND             reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    COMMA           reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    RPAREN          reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    SEMICOLON       reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)
    RBRACKET        reduce using rule 101 (factor -> LPAREN push_paren exp RPAREN pop_paren .)


state 278

    (87) write_aux -> CTESTRING save_string COMMA generate_write write_aux .

    RPAREN          reduce using rule 87 (write_aux -> CTESTRING save_string COMMA generate_write write_aux .)


state 279

    (91) exp -> l_exp pop_op_lop OR push_op exp .

    COMMA           reduce using rule 91 (exp -> l_exp pop_op_lop OR push_op exp .)
    RPAREN          reduce using rule 91 (exp -> l_exp pop_op_lop OR push_op exp .)
    SEMICOLON       reduce using rule 91 (exp -> l_exp pop_op_lop OR push_op exp .)
    RBRACKET        reduce using rule 91 (exp -> l_exp pop_op_lop OR push_op exp .)


state 280

    (92) exp -> l_exp pop_op_lop AND push_op exp .

    COMMA           reduce using rule 92 (exp -> l_exp pop_op_lop AND push_op exp .)
    RPAREN          reduce using rule 92 (exp -> l_exp pop_op_lop AND push_op exp .)
    SEMICOLON       reduce using rule 92 (exp -> l_exp pop_op_lop AND push_op exp .)
    RBRACKET        reduce using rule 92 (exp -> l_exp pop_op_lop AND push_op exp .)


state 281

    (94) l_exp -> a_exp RELOP push_op a_exp pop_op_relop .

    OR              reduce using rule 94 (l_exp -> a_exp RELOP push_op a_exp pop_op_relop .)
    AND             reduce using rule 94 (l_exp -> a_exp RELOP push_op a_exp pop_op_relop .)
    COMMA           reduce using rule 94 (l_exp -> a_exp RELOP push_op a_exp pop_op_relop .)
    RPAREN          reduce using rule 94 (l_exp -> a_exp RELOP push_op a_exp pop_op_relop .)
    SEMICOLON       reduce using rule 94 (l_exp -> a_exp RELOP push_op a_exp pop_op_relop .)
    RBRACKET        reduce using rule 94 (l_exp -> a_exp RELOP push_op a_exp pop_op_relop .)


state 282

    (96) a_exp -> term pop_op_art_n2 PLUS push_op a_exp .

    RELOP           reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)
    OR              reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)
    AND             reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)
    COMMA           reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)
    RPAREN          reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)
    SEMICOLON       reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)
    RBRACKET        reduce using rule 96 (a_exp -> term pop_op_art_n2 PLUS push_op a_exp .)


state 283

    (97) a_exp -> term pop_op_art_n2 MINUS push_op a_exp .

    RELOP           reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)
    OR              reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)
    AND             reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)
    COMMA           reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)
    RPAREN          reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)
    SEMICOLON       reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)
    RBRACKET        reduce using rule 97 (a_exp -> term pop_op_art_n2 MINUS push_op a_exp .)


state 284

    (99) term -> factor pop_op_art_n1 TIMES push_op term .

    PLUS            reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    MINUS           reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    RELOP           reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    OR              reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    AND             reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    COMMA           reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    RPAREN          reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    SEMICOLON       reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)
    RBRACKET        reduce using rule 99 (term -> factor pop_op_art_n1 TIMES push_op term .)


state 285

    (100) term -> factor pop_op_art_n1 DIVIDE push_op term .

    PLUS            reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    MINUS           reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    RELOP           reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    OR              reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    AND             reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    COMMA           reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    RPAREN          reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    SEMICOLON       reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)
    RBRACKET        reduce using rule 100 (term -> factor pop_op_art_n1 DIVIDE push_op term .)


state 286

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE . statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 301
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 287

    (88) while -> WHILE while_jump LPAREN exp RPAREN while_condition DO . LBRACE statutes_aux RBRACE end_while

    LBRACE          shift and go to state 302


state 288

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN . exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 303
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 289

    (41) body -> LBRACE start_function dec_vars statutes_aux RBRACE end_function .

    FUNCT           reduce using rule 41 (body -> LBRACE start_function dec_vars statutes_aux RBRACE end_function .)
    RBRACE          reduce using rule 41 (body -> LBRACE start_function dec_vars statutes_aux RBRACE end_function .)
    INIT            reduce using rule 41 (body -> LBRACE start_function dec_vars statutes_aux RBRACE end_function .)


state 290

    (44) body -> LBRACE start_function dec_vars statutes_aux RETURN ID . return_function SEMICOLON RBRACE end_function
    (150) return_function -> .

    SEMICOLON       reduce using rule 150 (return_function -> .)

    return_function                shift and go to state 304

state 291

    (43) body -> LBRACE start_function statutes_aux RETURN ID return_function . SEMICOLON RBRACE end_function

    SEMICOLON       shift and go to state 305


state 292

    (45) body -> LBRACE start_function RETURN ID return_function SEMICOLON . RBRACE end_function

    RBRACE          shift and go to state 306


state 293

    (65) call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN . pop_paren gosub_function
    (132) pop_paren -> .

    SEMICOLON       reduce using rule 132 (pop_paren -> .)
    TIMES           reduce using rule 132 (pop_paren -> .)
    DIVIDE          reduce using rule 132 (pop_paren -> .)
    PLUS            reduce using rule 132 (pop_paren -> .)
    MINUS           reduce using rule 132 (pop_paren -> .)
    RELOP           reduce using rule 132 (pop_paren -> .)
    OR              reduce using rule 132 (pop_paren -> .)
    AND             reduce using rule 132 (pop_paren -> .)
    COMMA           reduce using rule 132 (pop_paren -> .)
    RPAREN          reduce using rule 132 (pop_paren -> .)
    RBRACKET        reduce using rule 132 (pop_paren -> .)

    pop_paren                      shift and go to state 307

state 294

    (67) call_aux -> exp arg_function .
    (68) call_aux -> exp arg_function . COMMA call_aux

    RPAREN          reduce using rule 67 (call_aux -> exp arg_function .)
    COMMA           shift and go to state 308


state 295

    (64) call -> ID POINT ID exist_method LPAREN era_method RPAREN . gosub_method
    (165) gosub_method -> .

    SEMICOLON       reduce using rule 165 (gosub_method -> .)
    TIMES           reduce using rule 165 (gosub_method -> .)
    DIVIDE          reduce using rule 165 (gosub_method -> .)
    PLUS            reduce using rule 165 (gosub_method -> .)
    MINUS           reduce using rule 165 (gosub_method -> .)
    RELOP           reduce using rule 165 (gosub_method -> .)
    OR              reduce using rule 165 (gosub_method -> .)
    AND             reduce using rule 165 (gosub_method -> .)
    COMMA           reduce using rule 165 (gosub_method -> .)
    RPAREN          reduce using rule 165 (gosub_method -> .)
    RBRACKET        reduce using rule 165 (gosub_method -> .)

    gosub_method                   shift and go to state 309

state 296

    (66) call -> ID POINT ID exist_method LPAREN push_paren era_method . call_aux_2 RPAREN pop_paren gosub_method
    (69) call_aux_2 -> . exp arg_method
    (70) call_aux_2 -> . exp arg_method COMMA call_aux_2
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    call_aux_2                     shift and go to state 310
    exp                            shift and go to state 311
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 297

    (61) var_aux_3 -> LBRACKET . access_matrix exp verify_matrix_index RBRACKET end_matrix
    (159) access_matrix -> .

    LPAREN          reduce using rule 159 (access_matrix -> .)
    PLUS            reduce using rule 159 (access_matrix -> .)
    MINUS           reduce using rule 159 (access_matrix -> .)
    ID              reduce using rule 159 (access_matrix -> .)
    CTEI            reduce using rule 159 (access_matrix -> .)
    CTEF            reduce using rule 159 (access_matrix -> .)
    CTECHAR         reduce using rule 159 (access_matrix -> .)

    access_matrix                  shift and go to state 312

state 298

    (60) var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .

    EQUAL           reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    COMMA           reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    RPAREN          reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    TIMES           reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    DIVIDE          reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    PLUS            reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    MINUS           reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    RELOP           reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    OR              reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    AND             reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    SEMICOLON       reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)
    RBRACKET        reduce using rule 60 (var_aux_2 -> LBRACKET access_array exp verify_array_index RBRACKET var_aux_3 .)


state 299

    (62) var_aux_3 -> end_array .

    EQUAL           reduce using rule 62 (var_aux_3 -> end_array .)
    COMMA           reduce using rule 62 (var_aux_3 -> end_array .)
    RPAREN          reduce using rule 62 (var_aux_3 -> end_array .)
    TIMES           reduce using rule 62 (var_aux_3 -> end_array .)
    DIVIDE          reduce using rule 62 (var_aux_3 -> end_array .)
    PLUS            reduce using rule 62 (var_aux_3 -> end_array .)
    MINUS           reduce using rule 62 (var_aux_3 -> end_array .)
    RELOP           reduce using rule 62 (var_aux_3 -> end_array .)
    OR              reduce using rule 62 (var_aux_3 -> end_array .)
    AND             reduce using rule 62 (var_aux_3 -> end_array .)
    SEMICOLON       reduce using rule 62 (var_aux_3 -> end_array .)
    RBRACKET        reduce using rule 62 (var_aux_3 -> end_array .)


state 300

    (82) read_aux -> ID push_var var_aux_2 COMMA generate_read read_aux .

    RPAREN          reduce using rule 82 (read_aux -> ID push_var var_aux_2 COMMA generate_read read_aux .)


state 301

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux . RBRACE condition_aux_elif condition_aux_else end_if

    RBRACE          shift and go to state 313


state 302

    (88) while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE . statutes_aux RBRACE end_while
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 314
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 303

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp . RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    RPAREN          shift and go to state 315


state 304

    (44) body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function . SEMICOLON RBRACE end_function

    SEMICOLON       shift and go to state 316


state 305

    (43) body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON . RBRACE end_function

    RBRACE          shift and go to state 317


state 306

    (45) body -> LBRACE start_function RETURN ID return_function SEMICOLON RBRACE . end_function
    (151) end_function -> .

    FUNCT           reduce using rule 151 (end_function -> .)
    RBRACE          reduce using rule 151 (end_function -> .)
    INIT            reduce using rule 151 (end_function -> .)

    end_function                   shift and go to state 318

state 307

    (65) call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren . gosub_function
    (155) gosub_function -> .

    SEMICOLON       reduce using rule 155 (gosub_function -> .)
    TIMES           reduce using rule 155 (gosub_function -> .)
    DIVIDE          reduce using rule 155 (gosub_function -> .)
    PLUS            reduce using rule 155 (gosub_function -> .)
    MINUS           reduce using rule 155 (gosub_function -> .)
    RELOP           reduce using rule 155 (gosub_function -> .)
    OR              reduce using rule 155 (gosub_function -> .)
    AND             reduce using rule 155 (gosub_function -> .)
    COMMA           reduce using rule 155 (gosub_function -> .)
    RPAREN          reduce using rule 155 (gosub_function -> .)
    RBRACKET        reduce using rule 155 (gosub_function -> .)

    gosub_function                 shift and go to state 319

state 308

    (68) call_aux -> exp arg_function COMMA . call_aux
    (67) call_aux -> . exp arg_function
    (68) call_aux -> . exp arg_function COMMA call_aux
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 269
    call_aux                       shift and go to state 320
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 309

    (64) call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .

    SEMICOLON       reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    TIMES           reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    DIVIDE          reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    PLUS            reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    MINUS           reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    RELOP           reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    OR              reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    AND             reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    COMMA           reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    RPAREN          reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)
    RBRACKET        reduce using rule 64 (call -> ID POINT ID exist_method LPAREN era_method RPAREN gosub_method .)


state 310

    (66) call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 . RPAREN pop_paren gosub_method

    RPAREN          shift and go to state 321


state 311

    (69) call_aux_2 -> exp . arg_method
    (70) call_aux_2 -> exp . arg_method COMMA call_aux_2
    (164) arg_method -> .

    COMMA           reduce using rule 164 (arg_method -> .)
    RPAREN          reduce using rule 164 (arg_method -> .)

    arg_method                     shift and go to state 322

state 312

    (61) var_aux_3 -> LBRACKET access_matrix . exp verify_matrix_index RBRACKET end_matrix
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 323
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 313

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE . condition_aux_elif condition_aux_else end_if
    (72) condition_aux_elif -> . ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif
    (73) condition_aux_elif -> . empty
    (115) empty -> .

    ELIF            shift and go to state 325
    ELSE            reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)

    condition_aux_elif             shift and go to state 324
    empty                          shift and go to state 326

state 314

    (88) while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux . RBRACE end_while

    RBRACE          shift and go to state 327


state 315

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN . for_condition DO LBRACE statutes_aux RBRACE end_for
    (145) for_condition -> .

    DO              reduce using rule 145 (for_condition -> .)

    for_condition                  shift and go to state 328

state 316

    (44) body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON . RBRACE end_function

    RBRACE          shift and go to state 329


state 317

    (43) body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE . end_function
    (151) end_function -> .

    FUNCT           reduce using rule 151 (end_function -> .)
    RBRACE          reduce using rule 151 (end_function -> .)
    INIT            reduce using rule 151 (end_function -> .)

    end_function                   shift and go to state 330

state 318

    (45) body -> LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function .

    FUNCT           reduce using rule 45 (body -> LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function .)
    RBRACE          reduce using rule 45 (body -> LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function .)
    INIT            reduce using rule 45 (body -> LBRACE start_function RETURN ID return_function SEMICOLON RBRACE end_function .)


state 319

    (65) call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .

    SEMICOLON       reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    TIMES           reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    DIVIDE          reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    PLUS            reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    MINUS           reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    RELOP           reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    OR              reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    AND             reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    COMMA           reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    RPAREN          reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)
    RBRACKET        reduce using rule 65 (call -> ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function .)


state 320

    (68) call_aux -> exp arg_function COMMA call_aux .

    RPAREN          reduce using rule 68 (call_aux -> exp arg_function COMMA call_aux .)


state 321

    (66) call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN . pop_paren gosub_method
    (132) pop_paren -> .

    SEMICOLON       reduce using rule 132 (pop_paren -> .)
    TIMES           reduce using rule 132 (pop_paren -> .)
    DIVIDE          reduce using rule 132 (pop_paren -> .)
    PLUS            reduce using rule 132 (pop_paren -> .)
    MINUS           reduce using rule 132 (pop_paren -> .)
    RELOP           reduce using rule 132 (pop_paren -> .)
    OR              reduce using rule 132 (pop_paren -> .)
    AND             reduce using rule 132 (pop_paren -> .)
    COMMA           reduce using rule 132 (pop_paren -> .)
    RPAREN          reduce using rule 132 (pop_paren -> .)
    RBRACKET        reduce using rule 132 (pop_paren -> .)

    pop_paren                      shift and go to state 331

state 322

    (69) call_aux_2 -> exp arg_method .
    (70) call_aux_2 -> exp arg_method . COMMA call_aux_2

    RPAREN          reduce using rule 69 (call_aux_2 -> exp arg_method .)
    COMMA           shift and go to state 332


state 323

    (61) var_aux_3 -> LBRACKET access_matrix exp . verify_matrix_index RBRACKET end_matrix
    (160) verify_matrix_index -> .

    RBRACKET        reduce using rule 160 (verify_matrix_index -> .)

    verify_matrix_index            shift and go to state 333

state 324

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif . condition_aux_else end_if
    (74) condition_aux_else -> . ELSE else_condition LBRACE statutes_aux RBRACE
    (75) condition_aux_else -> . empty
    (115) empty -> .

    ELSE            shift and go to state 335
    CALL            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)

    condition_aux_else             shift and go to state 334
    empty                          shift and go to state 336

state 325

    (72) condition_aux_elif -> ELIF . LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif

    LPAREN          shift and go to state 337


state 326

    (73) condition_aux_elif -> empty .

    ELSE            reduce using rule 73 (condition_aux_elif -> empty .)
    CALL            reduce using rule 73 (condition_aux_elif -> empty .)
    ID              reduce using rule 73 (condition_aux_elif -> empty .)
    READ            reduce using rule 73 (condition_aux_elif -> empty .)
    WRITE           reduce using rule 73 (condition_aux_elif -> empty .)
    IF              reduce using rule 73 (condition_aux_elif -> empty .)
    WHILE           reduce using rule 73 (condition_aux_elif -> empty .)
    FROM            reduce using rule 73 (condition_aux_elif -> empty .)
    RBRACE          reduce using rule 73 (condition_aux_elif -> empty .)
    RETURN          reduce using rule 73 (condition_aux_elif -> empty .)


state 327

    (88) while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE . end_while
    (143) end_while -> .

    CALL            reduce using rule 143 (end_while -> .)
    ID              reduce using rule 143 (end_while -> .)
    READ            reduce using rule 143 (end_while -> .)
    WRITE           reduce using rule 143 (end_while -> .)
    IF              reduce using rule 143 (end_while -> .)
    WHILE           reduce using rule 143 (end_while -> .)
    FROM            reduce using rule 143 (end_while -> .)
    RBRACE          reduce using rule 143 (end_while -> .)
    RETURN          reduce using rule 143 (end_while -> .)

    end_while                      shift and go to state 338

state 328

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition . DO LBRACE statutes_aux RBRACE end_for

    DO              shift and go to state 339


state 329

    (44) body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE . end_function
    (151) end_function -> .

    FUNCT           reduce using rule 151 (end_function -> .)
    RBRACE          reduce using rule 151 (end_function -> .)
    INIT            reduce using rule 151 (end_function -> .)

    end_function                   shift and go to state 340

state 330

    (43) body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .

    FUNCT           reduce using rule 43 (body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .)
    RBRACE          reduce using rule 43 (body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .)
    INIT            reduce using rule 43 (body -> LBRACE start_function statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .)


state 331

    (66) call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren . gosub_method
    (165) gosub_method -> .

    SEMICOLON       reduce using rule 165 (gosub_method -> .)
    TIMES           reduce using rule 165 (gosub_method -> .)
    DIVIDE          reduce using rule 165 (gosub_method -> .)
    PLUS            reduce using rule 165 (gosub_method -> .)
    MINUS           reduce using rule 165 (gosub_method -> .)
    RELOP           reduce using rule 165 (gosub_method -> .)
    OR              reduce using rule 165 (gosub_method -> .)
    AND             reduce using rule 165 (gosub_method -> .)
    COMMA           reduce using rule 165 (gosub_method -> .)
    RPAREN          reduce using rule 165 (gosub_method -> .)
    RBRACKET        reduce using rule 165 (gosub_method -> .)

    gosub_method                   shift and go to state 341

state 332

    (70) call_aux_2 -> exp arg_method COMMA . call_aux_2
    (69) call_aux_2 -> . exp arg_method
    (70) call_aux_2 -> . exp arg_method COMMA call_aux_2
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 311
    call_aux_2                     shift and go to state 342
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 333

    (61) var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index . RBRACKET end_matrix

    RBRACKET        shift and go to state 343


state 334

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else . end_if
    (140) end_if -> .

    CALL            reduce using rule 140 (end_if -> .)
    ID              reduce using rule 140 (end_if -> .)
    READ            reduce using rule 140 (end_if -> .)
    WRITE           reduce using rule 140 (end_if -> .)
    IF              reduce using rule 140 (end_if -> .)
    WHILE           reduce using rule 140 (end_if -> .)
    FROM            reduce using rule 140 (end_if -> .)
    RBRACE          reduce using rule 140 (end_if -> .)
    RETURN          reduce using rule 140 (end_if -> .)

    end_if                         shift and go to state 344

state 335

    (74) condition_aux_else -> ELSE . else_condition LBRACE statutes_aux RBRACE
    (139) else_condition -> .

    LBRACE          reduce using rule 139 (else_condition -> .)

    else_condition                 shift and go to state 345

state 336

    (75) condition_aux_else -> empty .

    CALL            reduce using rule 75 (condition_aux_else -> empty .)
    ID              reduce using rule 75 (condition_aux_else -> empty .)
    READ            reduce using rule 75 (condition_aux_else -> empty .)
    WRITE           reduce using rule 75 (condition_aux_else -> empty .)
    IF              reduce using rule 75 (condition_aux_else -> empty .)
    WHILE           reduce using rule 75 (condition_aux_else -> empty .)
    FROM            reduce using rule 75 (condition_aux_else -> empty .)
    RBRACE          reduce using rule 75 (condition_aux_else -> empty .)
    RETURN          reduce using rule 75 (condition_aux_else -> empty .)


state 337

    (72) condition_aux_elif -> ELIF LPAREN . elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif
    (138) elif_expression -> .

    LPAREN          reduce using rule 138 (elif_expression -> .)
    PLUS            reduce using rule 138 (elif_expression -> .)
    MINUS           reduce using rule 138 (elif_expression -> .)
    ID              reduce using rule 138 (elif_expression -> .)
    CTEI            reduce using rule 138 (elif_expression -> .)
    CTEF            reduce using rule 138 (elif_expression -> .)
    CTECHAR         reduce using rule 138 (elif_expression -> .)

    elif_expression                shift and go to state 346

state 338

    (88) while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .

    CALL            reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    ID              reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    READ            reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    WRITE           reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    IF              reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    WHILE           reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    FROM            reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    RBRACE          reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)
    RETURN          reduce using rule 88 (while -> WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while .)


state 339

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO . LBRACE statutes_aux RBRACE end_for

    LBRACE          shift and go to state 347


state 340

    (44) body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .

    FUNCT           reduce using rule 44 (body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .)
    RBRACE          reduce using rule 44 (body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .)
    INIT            reduce using rule 44 (body -> LBRACE start_function dec_vars statutes_aux RETURN ID return_function SEMICOLON RBRACE end_function .)


state 341

    (66) call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .

    SEMICOLON       reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    TIMES           reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    DIVIDE          reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    PLUS            reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    MINUS           reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    RELOP           reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    OR              reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    AND             reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    COMMA           reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    RPAREN          reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)
    RBRACKET        reduce using rule 66 (call -> ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method .)


state 342

    (70) call_aux_2 -> exp arg_method COMMA call_aux_2 .

    RPAREN          reduce using rule 70 (call_aux_2 -> exp arg_method COMMA call_aux_2 .)


state 343

    (61) var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET . end_matrix
    (161) end_matrix -> .

    EQUAL           reduce using rule 161 (end_matrix -> .)
    COMMA           reduce using rule 161 (end_matrix -> .)
    RPAREN          reduce using rule 161 (end_matrix -> .)
    TIMES           reduce using rule 161 (end_matrix -> .)
    DIVIDE          reduce using rule 161 (end_matrix -> .)
    PLUS            reduce using rule 161 (end_matrix -> .)
    MINUS           reduce using rule 161 (end_matrix -> .)
    RELOP           reduce using rule 161 (end_matrix -> .)
    OR              reduce using rule 161 (end_matrix -> .)
    AND             reduce using rule 161 (end_matrix -> .)
    SEMICOLON       reduce using rule 161 (end_matrix -> .)
    RBRACKET        reduce using rule 161 (end_matrix -> .)

    end_matrix                     shift and go to state 348

state 344

    (71) condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .

    CALL            reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    ID              reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    READ            reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    WRITE           reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    IF              reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    WHILE           reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    FROM            reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    RBRACE          reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)
    RETURN          reduce using rule 71 (condition -> IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if .)


state 345

    (74) condition_aux_else -> ELSE else_condition . LBRACE statutes_aux RBRACE

    LBRACE          shift and go to state 349


state 346

    (72) condition_aux_elif -> ELIF LPAREN elif_expression . exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif
    (90) exp -> . l_exp pop_op_lop
    (91) exp -> . l_exp pop_op_lop OR push_op exp
    (92) exp -> . l_exp pop_op_lop AND push_op exp
    (93) l_exp -> . a_exp
    (94) l_exp -> . a_exp RELOP push_op a_exp pop_op_relop
    (95) a_exp -> . term pop_op_art_n2
    (96) a_exp -> . term pop_op_art_n2 PLUS push_op a_exp
    (97) a_exp -> . term pop_op_art_n2 MINUS push_op a_exp
    (98) term -> . factor pop_op_art_n1
    (99) term -> . factor pop_op_art_n1 TIMES push_op term
    (100) term -> . factor pop_op_art_n1 DIVIDE push_op term
    (101) factor -> . LPAREN push_paren exp RPAREN pop_paren
    (102) factor -> . factor_aux
    (103) factor -> . call
    (104) factor_aux -> . cte
    (105) factor_aux -> . PLUS cte
    (106) factor_aux -> . MINUS cte
    (63) call -> . ID exist_function LPAREN era_function RPAREN gosub_function
    (64) call -> . ID POINT ID exist_method LPAREN era_method RPAREN gosub_method
    (65) call -> . ID exist_function LPAREN push_paren era_function call_aux RPAREN pop_paren gosub_function
    (66) call -> . ID POINT ID exist_method LPAREN push_paren era_method call_aux_2 RPAREN pop_paren gosub_method
    (107) cte -> . ID push_var
    (108) cte -> . ID var_aux
    (109) cte -> . ID push_var var_aux_2
    (110) cte -> . CTEI push_var
    (111) cte -> . CTEF push_var
    (112) cte -> . CTECHAR push_var

    LPAREN          shift and go to state 141
    PLUS            shift and go to state 148
    MINUS           shift and go to state 149
    ID              shift and go to state 154
    CTEI            shift and go to state 155
    CTEF            shift and go to state 156
    CTECHAR         shift and go to state 157

    exp                            shift and go to state 350
    l_exp                          shift and go to state 145
    a_exp                          shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 150
    factor_aux                     shift and go to state 151
    call                           shift and go to state 152
    cte                            shift and go to state 153

state 347

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE . statutes_aux RBRACE end_for
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    assignation                    shift and go to state 86
    statutes_aux                   shift and go to state 351
    statutes                       shift and go to state 85
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 348

    (61) var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .

    EQUAL           reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    COMMA           reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    RPAREN          reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    TIMES           reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    DIVIDE          reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    PLUS            reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    MINUS           reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    RELOP           reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    OR              reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    AND             reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    SEMICOLON       reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)
    RBRACKET        reduce using rule 61 (var_aux_3 -> LBRACKET access_matrix exp verify_matrix_index RBRACKET end_matrix .)


state 349

    (74) condition_aux_else -> ELSE else_condition LBRACE . statutes_aux RBRACE
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 352
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 350

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp . RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif

    RPAREN          shift and go to state 353


state 351

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux . RBRACE end_for

    RBRACE          shift and go to state 354


state 352

    (74) condition_aux_else -> ELSE else_condition LBRACE statutes_aux . RBRACE

    RBRACE          shift and go to state 355


state 353

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN . elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif
    (137) elif_condition -> .

    THEN            reduce using rule 137 (elif_condition -> .)

    elif_condition                 shift and go to state 356

state 354

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE . end_for
    (146) end_for -> .

    CALL            reduce using rule 146 (end_for -> .)
    ID              reduce using rule 146 (end_for -> .)
    READ            reduce using rule 146 (end_for -> .)
    WRITE           reduce using rule 146 (end_for -> .)
    IF              reduce using rule 146 (end_for -> .)
    WHILE           reduce using rule 146 (end_for -> .)
    FROM            reduce using rule 146 (end_for -> .)
    RBRACE          reduce using rule 146 (end_for -> .)
    RETURN          reduce using rule 146 (end_for -> .)

    end_for                        shift and go to state 357

state 355

    (74) condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .

    CALL            reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    ID              reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    READ            reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    WRITE           reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    IF              reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    WHILE           reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    FROM            reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    RBRACE          reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)
    RETURN          reduce using rule 74 (condition_aux_else -> ELSE else_condition LBRACE statutes_aux RBRACE .)


state 356

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition . THEN LBRACE statutes_aux RBRACE condition_aux_elif

    THEN            shift and go to state 358


state 357

    (89) for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .

    CALL            reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    ID              reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    READ            reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    WRITE           reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    IF              reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    WHILE           reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    FROM            reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    RBRACE          reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)
    RETURN          reduce using rule 89 (for -> FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for .)


state 358

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN . LBRACE statutes_aux RBRACE condition_aux_elif

    LBRACE          shift and go to state 359


state 359

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE . statutes_aux RBRACE condition_aux_elif
    (53) statutes_aux -> . statutes
    (54) statutes_aux -> . statutes statutes_aux
    (46) statutes -> . assignation SEMICOLON
    (47) statutes -> . CALL call SEMICOLON
    (48) statutes -> . read
    (49) statutes -> . write
    (50) statutes -> . condition
    (51) statutes -> . while
    (52) statutes -> . for
    (55) assignation -> . ID push_var EQUAL push_op exp pop_op_assign
    (56) assignation -> . ID var_aux EQUAL push_op exp pop_op_assign
    (57) assignation -> . ID push_var var_aux_2 EQUAL push_op exp pop_op_assign
    (76) read -> . READ LPAREN read_aux RPAREN SEMICOLON generate_read
    (83) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON generate_write
    (71) condition -> . IF LPAREN exp RPAREN if_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif condition_aux_else end_if
    (88) while -> . WHILE while_jump LPAREN exp RPAREN while_condition DO LBRACE statutes_aux RBRACE end_while
    (89) for -> . FROM LPAREN assignation RPAREN UNTIL for_jump LPAREN exp RPAREN for_condition DO LBRACE statutes_aux RBRACE end_for

    CALL            shift and go to state 87
    ID              shift and go to state 93
    READ            shift and go to state 94
    WRITE           shift and go to state 95
    IF              shift and go to state 96
    WHILE           shift and go to state 97
    FROM            shift and go to state 98

    statutes_aux                   shift and go to state 360
    statutes                       shift and go to state 85
    assignation                    shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    condition                      shift and go to state 90
    while                          shift and go to state 91
    for                            shift and go to state 92

state 360

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux . RBRACE condition_aux_elif

    RBRACE          shift and go to state 361


state 361

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE . condition_aux_elif
    (72) condition_aux_elif -> . ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif
    (73) condition_aux_elif -> . empty
    (115) empty -> .

    ELIF            shift and go to state 325
    ELSE            reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)

    condition_aux_elif             shift and go to state 362
    empty                          shift and go to state 326

state 362

    (72) condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .

    ELSE            reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    CALL            reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    ID              reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    READ            reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    WRITE           reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    IF              reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    WHILE           reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    FROM            reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    RBRACE          reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)
    RETURN          reduce using rule 72 (condition_aux_elif -> ELIF LPAREN elif_expression exp RPAREN elif_condition THEN LBRACE statutes_aux RBRACE condition_aux_elif .)

