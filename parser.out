Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID TWOPOINTS program_aux main
Rule 2     program_aux -> dec_vars class_aux functions_aux
Rule 3     class_aux -> class
Rule 4     class_aux -> class class_aux
Rule 5     class_aux -> empty
Rule 6     functions_aux -> functions
Rule 7     functions_aux -> empty
Rule 8     dec_vars -> type_vars dec_vars_aux SEMICOLON
Rule 9     dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars
Rule 10    dec_vars -> empty
Rule 11    type_vars -> type_aux
Rule 12    type_vars -> type_aux LBRACKET exp RBRACKET
Rule 13    type_vars -> type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 14    dec_vars_aux -> ID
Rule 15    dec_vars_aux -> ID COMMA dec_vars_aux
Rule 16    functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE
Rule 17    functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE
Rule 18    functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions
Rule 19    functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions
Rule 20    functType -> VOID
Rule 21    functType -> type
Rule 22    params -> type ID
Rule 23    params -> type ID COMMA params
Rule 24    type -> type_aux
Rule 25    type -> type_aux LBRACKET RBRACKET
Rule 26    type -> type_aux LBRACKET RBRACKET LBRACKET RBRACKET
Rule 27    type_aux -> INT
Rule 28    type_aux -> FLOAT
Rule 29    type_aux -> CHAR
Rule 30    type_aux -> STRING
Rule 31    type_aux -> BOOL
Rule 32    type_aux -> ID
Rule 33    functBody -> statutes_aux
Rule 34    functBody -> dec_vars statutes_aux
Rule 35    return -> RETURN expression SEMICOLON
Rule 36    return -> empty
Rule 37    statutes -> assignation
Rule 38    statutes -> call SEMICOLON
Rule 39    statutes -> read
Rule 40    statutes -> write
Rule 41    statutes -> condition
Rule 42    statutes -> while
Rule 43    statutes -> for
Rule 44    assignation -> vars EQUAL expression SEMICOLON
Rule 45    write -> WRITE LPAREN write_aux RPAREN SEMICOLON
Rule 46    write_aux -> expression
Rule 47    write_aux -> expression COMMA write_aux
Rule 48    condition -> IF condition_aux
Rule 49    condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2
Rule 50    condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE
Rule 51    statutes_aux -> statutes
Rule 52    statutes_aux -> statutes statutes_aux
Rule 53    condition_aux_2 -> ELIF condition_aux
Rule 54    condition_aux_2 -> empty
Rule 55    while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
Rule 56    for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
Rule 57    class -> CLASS ID LBRACE dec_vars functions RBRACE
Rule 58    class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE
Rule 59    main -> MAIN LBRACE statutes_aux RBRACE
Rule 60    main -> MAIN LBRACE dec_vars statutes_aux RBRACE
Rule 61    expression -> expression_aux
Rule 62    expression -> expression_aux RELOP expression_aux
Rule 63    expression -> expression_aux AND expression_aux
Rule 64    expression -> expression_aux OR expression_aux
Rule 65    expression_aux -> call
Rule 66    expression_aux -> exp
Rule 67    call -> ID LPAREN call_aux RPAREN
Rule 68    call -> ID POINT ID LPAREN call_aux RPAREN
Rule 69    call_aux -> call_aux_2
Rule 70    call_aux -> empty
Rule 71    call_aux_2 -> exp
Rule 72    call_aux_2 -> exp COMMA call_aux_2
Rule 73    read -> READ LPAREN read_aux RPAREN SEMICOLON
Rule 74    read_aux -> vars
Rule 75    read_aux -> vars COMMA read_aux
Rule 76    vars -> ID
Rule 77    vars -> ID vars_aux
Rule 78    vars_aux -> LBRACKET exp RBRACKET
Rule 79    vars_aux -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 80    exp -> term
Rule 81    exp -> term PLUS exp
Rule 82    exp -> term MINUS exp
Rule 83    term -> factor
Rule 84    term -> factor TIMES term
Rule 85    term -> factor DIVIDE term
Rule 86    factor -> PLUS cte
Rule 87    factor -> MINUS cte
Rule 88    factor -> cte
Rule 89    factor -> LPAREN expression RPAREN
Rule 90    cte -> ID
Rule 91    cte -> CTEI
Rule 92    cte -> CTEF
Rule 93    cte -> CTESTRING
Rule 94    cte -> CTECHAR
Rule 95    empty -> <empty>

Terminals, with rules where they appear

AND                  : 63
BOOL                 : 31
CHAR                 : 29
CLASS                : 57 58
COMMA                : 15 23 47 72 75
CTECHAR              : 94
CTEF                 : 92
CTEI                 : 91
CTESTRING            : 93
DIVIDE               : 85
DO                   : 55 56
ELIF                 : 53
ELSE                 : 50
EQUAL                : 44
FLOAT                : 28
FROM                 : 56
ID                   : 1 14 15 16 17 18 19 22 23 32 57 58 58 67 68 68 76 77 90
IF                   : 48
INHERITS             : 58
INT                  : 27
LBRACE               : 16 17 18 19 49 50 50 55 56 57 58 59 60
LBRACKET             : 12 13 13 25 26 26 78 79 79
LPAREN               : 16 17 18 19 45 49 50 55 67 68 73 89
MAIN                 : 59 60
MINUS                : 82 87
OR                   : 64
PLUS                 : 81 86
POINT                : 68
PROGRAM              : 1
RBRACE               : 16 17 18 19 49 50 50 55 56 57 58 59 60
RBRACKET             : 12 13 13 25 26 26 78 79 79
READ                 : 73
RELOP                : 62
RETURN               : 35
RPAREN               : 16 17 18 19 45 49 50 55 67 68 73 89
SEMICOLON            : 8 9 35 38 44 45 73
STRING               : 30
THEN                 : 49 50
TIMES                : 84
TWOPOINTS            : 1
UNTIL                : 56
VOID                 : 20
WHILE                : 55
WRITE                : 45
error                : 

Nonterminals, with rules where they appear

assignation          : 37 56
call                 : 38 65
call_aux             : 67 68
call_aux_2           : 69 72
class                : 3 4
class_aux            : 2 4
condition            : 41
condition_aux        : 48 53
condition_aux_2      : 49 50
cte                  : 86 87 88
dec_vars             : 2 9 34 57 58 60
dec_vars_aux         : 8 9 15
empty                : 5 7 10 36 54 70
exp                  : 12 13 13 66 71 72 78 79 79 81 82
expression           : 35 44 46 47 49 50 55 56 89
expression_aux       : 61 62 62 63 63 64 64
factor               : 83 84 85
for                  : 43
functBody            : 16 17 18 19
functType            : 16 17 18 19
functions            : 6 18 19 57 58
functions_aux        : 2
main                 : 1
params               : 17 19 23
program              : 0
program_aux          : 1
read                 : 39
read_aux             : 73 75
return               : 16 17 18 19
statutes             : 51 52
statutes_aux         : 33 34 49 50 50 52 55 56 59 60
term                 : 80 81 82 84 85
type                 : 21 22 23
type_aux             : 11 12 13 24 25 26
type_vars            : 8 9
vars                 : 44 74 75
vars_aux             : 77
while                : 42
write                : 40
write_aux            : 45 47

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID TWOPOINTS program_aux main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID TWOPOINTS program_aux main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . TWOPOINTS program_aux main

    TWOPOINTS       shift and go to state 4


state 4

    (1) program -> PROGRAM ID TWOPOINTS . program_aux main
    (2) program_aux -> . dec_vars class_aux functions_aux
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CLASS           reduce using rule 95 (empty -> .)
    VOID            reduce using rule 95 (empty -> .)
    MAIN            reduce using rule 95 (empty -> .)
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! CHAR            [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! BOOL            [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]

    program_aux                    shift and go to state 6
    dec_vars                       shift and go to state 7
    type_vars                      shift and go to state 8
    empty                          shift and go to state 9
    type_aux                       shift and go to state 10

state 5

    (32) type_aux -> ID .

    LBRACKET        reduce using rule 32 (type_aux -> ID .)
    ID              reduce using rule 32 (type_aux -> ID .)


state 6

    (1) program -> PROGRAM ID TWOPOINTS program_aux . main
    (59) main -> . MAIN LBRACE statutes_aux RBRACE
    (60) main -> . MAIN LBRACE dec_vars statutes_aux RBRACE

    MAIN            shift and go to state 17

    main                           shift and go to state 16

state 7

    (2) program_aux -> dec_vars . class_aux functions_aux
    (3) class_aux -> . class
    (4) class_aux -> . class class_aux
    (5) class_aux -> . empty
    (57) class -> . CLASS ID LBRACE dec_vars functions RBRACE
    (58) class -> . CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE
    (95) empty -> .

    CLASS           shift and go to state 21
    VOID            reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    CHAR            reduce using rule 95 (empty -> .)
    STRING          reduce using rule 95 (empty -> .)
    BOOL            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    MAIN            reduce using rule 95 (empty -> .)

    class_aux                      shift and go to state 18
    class                          shift and go to state 19
    empty                          shift and go to state 20

state 8

    (8) dec_vars -> type_vars . dec_vars_aux SEMICOLON
    (9) dec_vars -> type_vars . dec_vars_aux SEMICOLON dec_vars
    (14) dec_vars_aux -> . ID
    (15) dec_vars_aux -> . ID COMMA dec_vars_aux

    ID              shift and go to state 23

    dec_vars_aux                   shift and go to state 22

state 9

    (10) dec_vars -> empty .

    CLASS           reduce using rule 10 (dec_vars -> empty .)
    VOID            reduce using rule 10 (dec_vars -> empty .)
    INT             reduce using rule 10 (dec_vars -> empty .)
    FLOAT           reduce using rule 10 (dec_vars -> empty .)
    CHAR            reduce using rule 10 (dec_vars -> empty .)
    STRING          reduce using rule 10 (dec_vars -> empty .)
    BOOL            reduce using rule 10 (dec_vars -> empty .)
    ID              reduce using rule 10 (dec_vars -> empty .)
    MAIN            reduce using rule 10 (dec_vars -> empty .)
    READ            reduce using rule 10 (dec_vars -> empty .)
    WRITE           reduce using rule 10 (dec_vars -> empty .)
    IF              reduce using rule 10 (dec_vars -> empty .)
    WHILE           reduce using rule 10 (dec_vars -> empty .)
    FROM            reduce using rule 10 (dec_vars -> empty .)


state 10

    (11) type_vars -> type_aux .
    (12) type_vars -> type_aux . LBRACKET exp RBRACKET
    (13) type_vars -> type_aux . LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    ID              reduce using rule 11 (type_vars -> type_aux .)
    LBRACKET        shift and go to state 24


state 11

    (27) type_aux -> INT .

    LBRACKET        reduce using rule 27 (type_aux -> INT .)
    ID              reduce using rule 27 (type_aux -> INT .)


state 12

    (28) type_aux -> FLOAT .

    LBRACKET        reduce using rule 28 (type_aux -> FLOAT .)
    ID              reduce using rule 28 (type_aux -> FLOAT .)


state 13

    (29) type_aux -> CHAR .

    LBRACKET        reduce using rule 29 (type_aux -> CHAR .)
    ID              reduce using rule 29 (type_aux -> CHAR .)


state 14

    (30) type_aux -> STRING .

    LBRACKET        reduce using rule 30 (type_aux -> STRING .)
    ID              reduce using rule 30 (type_aux -> STRING .)


state 15

    (31) type_aux -> BOOL .

    LBRACKET        reduce using rule 31 (type_aux -> BOOL .)
    ID              reduce using rule 31 (type_aux -> BOOL .)


state 16

    (1) program -> PROGRAM ID TWOPOINTS program_aux main .

    $end            reduce using rule 1 (program -> PROGRAM ID TWOPOINTS program_aux main .)


state 17

    (59) main -> MAIN . LBRACE statutes_aux RBRACE
    (60) main -> MAIN . LBRACE dec_vars statutes_aux RBRACE

    LBRACE          shift and go to state 25


state 18

    (2) program_aux -> dec_vars class_aux . functions_aux
    (6) functions_aux -> . functions
    (7) functions_aux -> . empty
    (16) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions
    (95) empty -> .
    (20) functType -> . VOID
    (21) functType -> . type
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    MAIN            reduce using rule 95 (empty -> .)
    VOID            shift and go to state 30
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    functions_aux                  shift and go to state 26
    functions                      shift and go to state 27
    empty                          shift and go to state 28
    functType                      shift and go to state 29
    type                           shift and go to state 31
    type_aux                       shift and go to state 32

state 19

    (3) class_aux -> class .
    (4) class_aux -> class . class_aux
    (3) class_aux -> . class
    (4) class_aux -> . class class_aux
    (5) class_aux -> . empty
    (57) class -> . CLASS ID LBRACE dec_vars functions RBRACE
    (58) class -> . CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE
    (95) empty -> .

  ! reduce/reduce conflict for VOID resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for INT resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for FLOAT resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for CHAR resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for STRING resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for BOOL resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for ID resolved using rule 3 (class_aux -> class .)
  ! reduce/reduce conflict for MAIN resolved using rule 3 (class_aux -> class .)
    VOID            reduce using rule 3 (class_aux -> class .)
    INT             reduce using rule 3 (class_aux -> class .)
    FLOAT           reduce using rule 3 (class_aux -> class .)
    CHAR            reduce using rule 3 (class_aux -> class .)
    STRING          reduce using rule 3 (class_aux -> class .)
    BOOL            reduce using rule 3 (class_aux -> class .)
    ID              reduce using rule 3 (class_aux -> class .)
    MAIN            reduce using rule 3 (class_aux -> class .)
    CLASS           shift and go to state 21

  ! VOID            [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! CHAR            [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! BOOL            [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! MAIN            [ reduce using rule 95 (empty -> .) ]

    class                          shift and go to state 19
    class_aux                      shift and go to state 33
    empty                          shift and go to state 20

state 20

    (5) class_aux -> empty .

    VOID            reduce using rule 5 (class_aux -> empty .)
    INT             reduce using rule 5 (class_aux -> empty .)
    FLOAT           reduce using rule 5 (class_aux -> empty .)
    CHAR            reduce using rule 5 (class_aux -> empty .)
    STRING          reduce using rule 5 (class_aux -> empty .)
    BOOL            reduce using rule 5 (class_aux -> empty .)
    ID              reduce using rule 5 (class_aux -> empty .)
    MAIN            reduce using rule 5 (class_aux -> empty .)


state 21

    (57) class -> CLASS . ID LBRACE dec_vars functions RBRACE
    (58) class -> CLASS . ID INHERITS ID LBRACE dec_vars functions RBRACE

    ID              shift and go to state 34


state 22

    (8) dec_vars -> type_vars dec_vars_aux . SEMICOLON
    (9) dec_vars -> type_vars dec_vars_aux . SEMICOLON dec_vars

    SEMICOLON       shift and go to state 35


state 23

    (14) dec_vars_aux -> ID .
    (15) dec_vars_aux -> ID . COMMA dec_vars_aux

    SEMICOLON       reduce using rule 14 (dec_vars_aux -> ID .)
    COMMA           shift and go to state 36


state 24

    (12) type_vars -> type_aux LBRACKET . exp RBRACKET
    (13) type_vars -> type_aux LBRACKET . exp RBRACKET LBRACKET exp RBRACKET
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    exp                            shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 25

    (59) main -> MAIN LBRACE . statutes_aux RBRACE
    (60) main -> MAIN LBRACE . dec_vars statutes_aux RBRACE
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FROM resolved as shift
    ID              shift and go to state 60
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15

  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! READ            [ reduce using rule 95 (empty -> .) ]
  ! WRITE           [ reduce using rule 95 (empty -> .) ]
  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FROM            [ reduce using rule 95 (empty -> .) ]

    statutes_aux                   shift and go to state 49
    dec_vars                       shift and go to state 50
    statutes                       shift and go to state 51
    type_vars                      shift and go to state 8
    empty                          shift and go to state 9
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    type_aux                       shift and go to state 10
    vars                           shift and go to state 59

state 26

    (2) program_aux -> dec_vars class_aux functions_aux .

    MAIN            reduce using rule 2 (program_aux -> dec_vars class_aux functions_aux .)


state 27

    (6) functions_aux -> functions .

    MAIN            reduce using rule 6 (functions_aux -> functions .)


state 28

    (7) functions_aux -> empty .

    MAIN            reduce using rule 7 (functions_aux -> empty .)


state 29

    (16) functions -> functType . ID LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> functType . ID LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> functType . ID LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> functType . ID LPAREN params RPAREN LBRACE functBody return RBRACE functions

    ID              shift and go to state 66


state 30

    (20) functType -> VOID .

    ID              reduce using rule 20 (functType -> VOID .)


state 31

    (21) functType -> type .

    ID              reduce using rule 21 (functType -> type .)


state 32

    (24) type -> type_aux .
    (25) type -> type_aux . LBRACKET RBRACKET
    (26) type -> type_aux . LBRACKET RBRACKET LBRACKET RBRACKET

    ID              reduce using rule 24 (type -> type_aux .)
    LBRACKET        shift and go to state 67


state 33

    (4) class_aux -> class class_aux .

    VOID            reduce using rule 4 (class_aux -> class class_aux .)
    INT             reduce using rule 4 (class_aux -> class class_aux .)
    FLOAT           reduce using rule 4 (class_aux -> class class_aux .)
    CHAR            reduce using rule 4 (class_aux -> class class_aux .)
    STRING          reduce using rule 4 (class_aux -> class class_aux .)
    BOOL            reduce using rule 4 (class_aux -> class class_aux .)
    ID              reduce using rule 4 (class_aux -> class class_aux .)
    MAIN            reduce using rule 4 (class_aux -> class class_aux .)


state 34

    (57) class -> CLASS ID . LBRACE dec_vars functions RBRACE
    (58) class -> CLASS ID . INHERITS ID LBRACE dec_vars functions RBRACE

    LBRACE          shift and go to state 68
    INHERITS        shift and go to state 69


state 35

    (8) dec_vars -> type_vars dec_vars_aux SEMICOLON .
    (9) dec_vars -> type_vars dec_vars_aux SEMICOLON . dec_vars
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

  ! reduce/reduce conflict for CLASS resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for VOID resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for INT resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for CHAR resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for BOOL resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for MAIN resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for READ resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for WRITE resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for WHILE resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! reduce/reduce conflict for FROM resolved using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CLASS           reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    VOID            reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    MAIN            reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    READ            reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    WRITE           reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    IF              reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    WHILE           reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    FROM            reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .)
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

  ! INT             [ reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .) ]
  ! CHAR            [ reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .) ]
  ! STRING          [ reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .) ]
  ! BOOL            [ reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .) ]
  ! ID              [ reduce using rule 8 (dec_vars -> type_vars dec_vars_aux SEMICOLON .) ]
  ! CLASS           [ reduce using rule 95 (empty -> .) ]
  ! VOID            [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! CHAR            [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! BOOL            [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! MAIN            [ reduce using rule 95 (empty -> .) ]
  ! READ            [ reduce using rule 95 (empty -> .) ]
  ! WRITE           [ reduce using rule 95 (empty -> .) ]
  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FROM            [ reduce using rule 95 (empty -> .) ]

    type_vars                      shift and go to state 8
    dec_vars                       shift and go to state 70
    empty                          shift and go to state 9
    type_aux                       shift and go to state 10

state 36

    (15) dec_vars_aux -> ID COMMA . dec_vars_aux
    (14) dec_vars_aux -> . ID
    (15) dec_vars_aux -> . ID COMMA dec_vars_aux

    ID              shift and go to state 23

    dec_vars_aux                   shift and go to state 71

state 37

    (12) type_vars -> type_aux LBRACKET exp . RBRACKET
    (13) type_vars -> type_aux LBRACKET exp . RBRACKET LBRACKET exp RBRACKET

    RBRACKET        shift and go to state 72


state 38

    (80) exp -> term .
    (81) exp -> term . PLUS exp
    (82) exp -> term . MINUS exp

    RBRACKET        reduce using rule 80 (exp -> term .)
    RELOP           reduce using rule 80 (exp -> term .)
    AND             reduce using rule 80 (exp -> term .)
    OR              reduce using rule 80 (exp -> term .)
    RPAREN          reduce using rule 80 (exp -> term .)
    SEMICOLON       reduce using rule 80 (exp -> term .)
    COMMA           reduce using rule 80 (exp -> term .)
    DO              reduce using rule 80 (exp -> term .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 39

    (86) factor -> PLUS . cte
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    cte                            shift and go to state 75

state 40

    (87) factor -> MINUS . cte
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    cte                            shift and go to state 76

state 41

    (83) term -> factor .
    (84) term -> factor . TIMES term
    (85) term -> factor . DIVIDE term

    PLUS            reduce using rule 83 (term -> factor .)
    MINUS           reduce using rule 83 (term -> factor .)
    RBRACKET        reduce using rule 83 (term -> factor .)
    RELOP           reduce using rule 83 (term -> factor .)
    AND             reduce using rule 83 (term -> factor .)
    OR              reduce using rule 83 (term -> factor .)
    RPAREN          reduce using rule 83 (term -> factor .)
    SEMICOLON       reduce using rule 83 (term -> factor .)
    COMMA           reduce using rule 83 (term -> factor .)
    DO              reduce using rule 83 (term -> factor .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78


state 42

    (88) factor -> cte .

    TIMES           reduce using rule 88 (factor -> cte .)
    DIVIDE          reduce using rule 88 (factor -> cte .)
    PLUS            reduce using rule 88 (factor -> cte .)
    MINUS           reduce using rule 88 (factor -> cte .)
    RBRACKET        reduce using rule 88 (factor -> cte .)
    RELOP           reduce using rule 88 (factor -> cte .)
    AND             reduce using rule 88 (factor -> cte .)
    OR              reduce using rule 88 (factor -> cte .)
    RPAREN          reduce using rule 88 (factor -> cte .)
    SEMICOLON       reduce using rule 88 (factor -> cte .)
    COMMA           reduce using rule 88 (factor -> cte .)
    DO              reduce using rule 88 (factor -> cte .)


state 43

    (89) factor -> LPAREN . expression RPAREN
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 79
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 44

    (90) cte -> ID .

    TIMES           reduce using rule 90 (cte -> ID .)
    DIVIDE          reduce using rule 90 (cte -> ID .)
    PLUS            reduce using rule 90 (cte -> ID .)
    MINUS           reduce using rule 90 (cte -> ID .)
    RBRACKET        reduce using rule 90 (cte -> ID .)
    RELOP           reduce using rule 90 (cte -> ID .)
    AND             reduce using rule 90 (cte -> ID .)
    OR              reduce using rule 90 (cte -> ID .)
    RPAREN          reduce using rule 90 (cte -> ID .)
    SEMICOLON       reduce using rule 90 (cte -> ID .)
    COMMA           reduce using rule 90 (cte -> ID .)
    DO              reduce using rule 90 (cte -> ID .)


state 45

    (91) cte -> CTEI .

    TIMES           reduce using rule 91 (cte -> CTEI .)
    DIVIDE          reduce using rule 91 (cte -> CTEI .)
    PLUS            reduce using rule 91 (cte -> CTEI .)
    MINUS           reduce using rule 91 (cte -> CTEI .)
    RBRACKET        reduce using rule 91 (cte -> CTEI .)
    RELOP           reduce using rule 91 (cte -> CTEI .)
    AND             reduce using rule 91 (cte -> CTEI .)
    OR              reduce using rule 91 (cte -> CTEI .)
    RPAREN          reduce using rule 91 (cte -> CTEI .)
    SEMICOLON       reduce using rule 91 (cte -> CTEI .)
    COMMA           reduce using rule 91 (cte -> CTEI .)
    DO              reduce using rule 91 (cte -> CTEI .)


state 46

    (92) cte -> CTEF .

    TIMES           reduce using rule 92 (cte -> CTEF .)
    DIVIDE          reduce using rule 92 (cte -> CTEF .)
    PLUS            reduce using rule 92 (cte -> CTEF .)
    MINUS           reduce using rule 92 (cte -> CTEF .)
    RBRACKET        reduce using rule 92 (cte -> CTEF .)
    RELOP           reduce using rule 92 (cte -> CTEF .)
    AND             reduce using rule 92 (cte -> CTEF .)
    OR              reduce using rule 92 (cte -> CTEF .)
    RPAREN          reduce using rule 92 (cte -> CTEF .)
    SEMICOLON       reduce using rule 92 (cte -> CTEF .)
    COMMA           reduce using rule 92 (cte -> CTEF .)
    DO              reduce using rule 92 (cte -> CTEF .)


state 47

    (93) cte -> CTESTRING .

    TIMES           reduce using rule 93 (cte -> CTESTRING .)
    DIVIDE          reduce using rule 93 (cte -> CTESTRING .)
    PLUS            reduce using rule 93 (cte -> CTESTRING .)
    MINUS           reduce using rule 93 (cte -> CTESTRING .)
    RBRACKET        reduce using rule 93 (cte -> CTESTRING .)
    RELOP           reduce using rule 93 (cte -> CTESTRING .)
    AND             reduce using rule 93 (cte -> CTESTRING .)
    OR              reduce using rule 93 (cte -> CTESTRING .)
    RPAREN          reduce using rule 93 (cte -> CTESTRING .)
    SEMICOLON       reduce using rule 93 (cte -> CTESTRING .)
    COMMA           reduce using rule 93 (cte -> CTESTRING .)
    DO              reduce using rule 93 (cte -> CTESTRING .)


state 48

    (94) cte -> CTECHAR .

    TIMES           reduce using rule 94 (cte -> CTECHAR .)
    DIVIDE          reduce using rule 94 (cte -> CTECHAR .)
    PLUS            reduce using rule 94 (cte -> CTECHAR .)
    MINUS           reduce using rule 94 (cte -> CTECHAR .)
    RBRACKET        reduce using rule 94 (cte -> CTECHAR .)
    RELOP           reduce using rule 94 (cte -> CTECHAR .)
    AND             reduce using rule 94 (cte -> CTECHAR .)
    OR              reduce using rule 94 (cte -> CTECHAR .)
    RPAREN          reduce using rule 94 (cte -> CTECHAR .)
    SEMICOLON       reduce using rule 94 (cte -> CTECHAR .)
    COMMA           reduce using rule 94 (cte -> CTECHAR .)
    DO              reduce using rule 94 (cte -> CTECHAR .)


state 49

    (59) main -> MAIN LBRACE statutes_aux . RBRACE

    RBRACE          shift and go to state 84


state 50

    (60) main -> MAIN LBRACE dec_vars . statutes_aux RBRACE
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statutes_aux                   shift and go to state 85
    statutes                       shift and go to state 51
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 51

    (51) statutes_aux -> statutes .
    (52) statutes_aux -> statutes . statutes_aux
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    RBRACE          reduce using rule 51 (statutes_aux -> statutes .)
    RETURN          reduce using rule 51 (statutes_aux -> statutes .)
    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statutes                       shift and go to state 51
    statutes_aux                   shift and go to state 87
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 52

    (37) statutes -> assignation .

    ID              reduce using rule 37 (statutes -> assignation .)
    READ            reduce using rule 37 (statutes -> assignation .)
    WRITE           reduce using rule 37 (statutes -> assignation .)
    IF              reduce using rule 37 (statutes -> assignation .)
    WHILE           reduce using rule 37 (statutes -> assignation .)
    FROM            reduce using rule 37 (statutes -> assignation .)
    RBRACE          reduce using rule 37 (statutes -> assignation .)
    RETURN          reduce using rule 37 (statutes -> assignation .)


state 53

    (38) statutes -> call . SEMICOLON

    SEMICOLON       shift and go to state 88


state 54

    (39) statutes -> read .

    ID              reduce using rule 39 (statutes -> read .)
    READ            reduce using rule 39 (statutes -> read .)
    WRITE           reduce using rule 39 (statutes -> read .)
    IF              reduce using rule 39 (statutes -> read .)
    WHILE           reduce using rule 39 (statutes -> read .)
    FROM            reduce using rule 39 (statutes -> read .)
    RBRACE          reduce using rule 39 (statutes -> read .)
    RETURN          reduce using rule 39 (statutes -> read .)


state 55

    (40) statutes -> write .

    ID              reduce using rule 40 (statutes -> write .)
    READ            reduce using rule 40 (statutes -> write .)
    WRITE           reduce using rule 40 (statutes -> write .)
    IF              reduce using rule 40 (statutes -> write .)
    WHILE           reduce using rule 40 (statutes -> write .)
    FROM            reduce using rule 40 (statutes -> write .)
    RBRACE          reduce using rule 40 (statutes -> write .)
    RETURN          reduce using rule 40 (statutes -> write .)


state 56

    (41) statutes -> condition .

    ID              reduce using rule 41 (statutes -> condition .)
    READ            reduce using rule 41 (statutes -> condition .)
    WRITE           reduce using rule 41 (statutes -> condition .)
    IF              reduce using rule 41 (statutes -> condition .)
    WHILE           reduce using rule 41 (statutes -> condition .)
    FROM            reduce using rule 41 (statutes -> condition .)
    RBRACE          reduce using rule 41 (statutes -> condition .)
    RETURN          reduce using rule 41 (statutes -> condition .)


state 57

    (42) statutes -> while .

    ID              reduce using rule 42 (statutes -> while .)
    READ            reduce using rule 42 (statutes -> while .)
    WRITE           reduce using rule 42 (statutes -> while .)
    IF              reduce using rule 42 (statutes -> while .)
    WHILE           reduce using rule 42 (statutes -> while .)
    FROM            reduce using rule 42 (statutes -> while .)
    RBRACE          reduce using rule 42 (statutes -> while .)
    RETURN          reduce using rule 42 (statutes -> while .)


state 58

    (43) statutes -> for .

    ID              reduce using rule 43 (statutes -> for .)
    READ            reduce using rule 43 (statutes -> for .)
    WRITE           reduce using rule 43 (statutes -> for .)
    IF              reduce using rule 43 (statutes -> for .)
    WHILE           reduce using rule 43 (statutes -> for .)
    FROM            reduce using rule 43 (statutes -> for .)
    RBRACE          reduce using rule 43 (statutes -> for .)
    RETURN          reduce using rule 43 (statutes -> for .)


state 59

    (44) assignation -> vars . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 89


state 60

    (67) call -> ID . LPAREN call_aux RPAREN
    (68) call -> ID . POINT ID LPAREN call_aux RPAREN
    (32) type_aux -> ID .
    (76) vars -> ID .
    (77) vars -> ID . vars_aux
    (78) vars_aux -> . LBRACKET exp RBRACKET
    (79) vars_aux -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 90
    POINT           shift and go to state 91
    ID              reduce using rule 32 (type_aux -> ID .)
    EQUAL           reduce using rule 76 (vars -> ID .)
    LBRACKET        shift and go to state 93

  ! LBRACKET        [ reduce using rule 32 (type_aux -> ID .) ]

    vars_aux                       shift and go to state 92

state 61

    (73) read -> READ . LPAREN read_aux RPAREN SEMICOLON

    LPAREN          shift and go to state 94


state 62

    (45) write -> WRITE . LPAREN write_aux RPAREN SEMICOLON

    LPAREN          shift and go to state 95


state 63

    (48) condition -> IF . condition_aux
    (49) condition_aux -> . LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> . LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE

    LPAREN          shift and go to state 97

    condition_aux                  shift and go to state 96

state 64

    (55) while -> WHILE . LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE

    LPAREN          shift and go to state 98


state 65

    (56) for -> FROM . assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 100

    assignation                    shift and go to state 99
    vars                           shift and go to state 59

state 66

    (16) functions -> functType ID . LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> functType ID . LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> functType ID . LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> functType ID . LPAREN params RPAREN LBRACE functBody return RBRACE functions

    LPAREN          shift and go to state 101


state 67

    (25) type -> type_aux LBRACKET . RBRACKET
    (26) type -> type_aux LBRACKET . RBRACKET LBRACKET RBRACKET

    RBRACKET        shift and go to state 102


state 68

    (57) class -> CLASS ID LBRACE . dec_vars functions RBRACE
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    VOID            reduce using rule 95 (empty -> .)
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! CHAR            [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! BOOL            [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]

    dec_vars                       shift and go to state 103
    type_vars                      shift and go to state 8
    empty                          shift and go to state 9
    type_aux                       shift and go to state 10

state 69

    (58) class -> CLASS ID INHERITS . ID LBRACE dec_vars functions RBRACE

    ID              shift and go to state 104


state 70

    (9) dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .

    CLASS           reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    VOID            reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    INT             reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    FLOAT           reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    CHAR            reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    STRING          reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    BOOL            reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    ID              reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    MAIN            reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    READ            reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    WRITE           reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    IF              reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    WHILE           reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)
    FROM            reduce using rule 9 (dec_vars -> type_vars dec_vars_aux SEMICOLON dec_vars .)


state 71

    (15) dec_vars_aux -> ID COMMA dec_vars_aux .

    SEMICOLON       reduce using rule 15 (dec_vars_aux -> ID COMMA dec_vars_aux .)


state 72

    (12) type_vars -> type_aux LBRACKET exp RBRACKET .
    (13) type_vars -> type_aux LBRACKET exp RBRACKET . LBRACKET exp RBRACKET

    ID              reduce using rule 12 (type_vars -> type_aux LBRACKET exp RBRACKET .)
    LBRACKET        shift and go to state 105


state 73

    (81) exp -> term PLUS . exp
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    term                           shift and go to state 38
    exp                            shift and go to state 106
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 74

    (82) exp -> term MINUS . exp
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    term                           shift and go to state 38
    exp                            shift and go to state 107
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 75

    (86) factor -> PLUS cte .

    TIMES           reduce using rule 86 (factor -> PLUS cte .)
    DIVIDE          reduce using rule 86 (factor -> PLUS cte .)
    PLUS            reduce using rule 86 (factor -> PLUS cte .)
    MINUS           reduce using rule 86 (factor -> PLUS cte .)
    RBRACKET        reduce using rule 86 (factor -> PLUS cte .)
    RELOP           reduce using rule 86 (factor -> PLUS cte .)
    AND             reduce using rule 86 (factor -> PLUS cte .)
    OR              reduce using rule 86 (factor -> PLUS cte .)
    RPAREN          reduce using rule 86 (factor -> PLUS cte .)
    SEMICOLON       reduce using rule 86 (factor -> PLUS cte .)
    COMMA           reduce using rule 86 (factor -> PLUS cte .)
    DO              reduce using rule 86 (factor -> PLUS cte .)


state 76

    (87) factor -> MINUS cte .

    TIMES           reduce using rule 87 (factor -> MINUS cte .)
    DIVIDE          reduce using rule 87 (factor -> MINUS cte .)
    PLUS            reduce using rule 87 (factor -> MINUS cte .)
    MINUS           reduce using rule 87 (factor -> MINUS cte .)
    RBRACKET        reduce using rule 87 (factor -> MINUS cte .)
    RELOP           reduce using rule 87 (factor -> MINUS cte .)
    AND             reduce using rule 87 (factor -> MINUS cte .)
    OR              reduce using rule 87 (factor -> MINUS cte .)
    RPAREN          reduce using rule 87 (factor -> MINUS cte .)
    SEMICOLON       reduce using rule 87 (factor -> MINUS cte .)
    COMMA           reduce using rule 87 (factor -> MINUS cte .)
    DO              reduce using rule 87 (factor -> MINUS cte .)


state 77

    (84) term -> factor TIMES . term
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    factor                         shift and go to state 41
    term                           shift and go to state 108
    cte                            shift and go to state 42

state 78

    (85) term -> factor DIVIDE . term
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    factor                         shift and go to state 41
    term                           shift and go to state 109
    cte                            shift and go to state 42

state 79

    (89) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 110


state 80

    (61) expression -> expression_aux .
    (62) expression -> expression_aux . RELOP expression_aux
    (63) expression -> expression_aux . AND expression_aux
    (64) expression -> expression_aux . OR expression_aux

    RPAREN          reduce using rule 61 (expression -> expression_aux .)
    SEMICOLON       reduce using rule 61 (expression -> expression_aux .)
    COMMA           reduce using rule 61 (expression -> expression_aux .)
    DO              reduce using rule 61 (expression -> expression_aux .)
    RELOP           shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113


state 81

    (65) expression_aux -> call .

    RELOP           reduce using rule 65 (expression_aux -> call .)
    AND             reduce using rule 65 (expression_aux -> call .)
    OR              reduce using rule 65 (expression_aux -> call .)
    RPAREN          reduce using rule 65 (expression_aux -> call .)
    SEMICOLON       reduce using rule 65 (expression_aux -> call .)
    COMMA           reduce using rule 65 (expression_aux -> call .)
    DO              reduce using rule 65 (expression_aux -> call .)


state 82

    (66) expression_aux -> exp .

    RELOP           reduce using rule 66 (expression_aux -> exp .)
    AND             reduce using rule 66 (expression_aux -> exp .)
    OR              reduce using rule 66 (expression_aux -> exp .)
    RPAREN          reduce using rule 66 (expression_aux -> exp .)
    SEMICOLON       reduce using rule 66 (expression_aux -> exp .)
    COMMA           reduce using rule 66 (expression_aux -> exp .)
    DO              reduce using rule 66 (expression_aux -> exp .)


state 83

    (67) call -> ID . LPAREN call_aux RPAREN
    (68) call -> ID . POINT ID LPAREN call_aux RPAREN
    (90) cte -> ID .

    LPAREN          shift and go to state 90
    POINT           shift and go to state 91
    TIMES           reduce using rule 90 (cte -> ID .)
    DIVIDE          reduce using rule 90 (cte -> ID .)
    PLUS            reduce using rule 90 (cte -> ID .)
    MINUS           reduce using rule 90 (cte -> ID .)
    RELOP           reduce using rule 90 (cte -> ID .)
    AND             reduce using rule 90 (cte -> ID .)
    OR              reduce using rule 90 (cte -> ID .)
    RPAREN          reduce using rule 90 (cte -> ID .)
    SEMICOLON       reduce using rule 90 (cte -> ID .)
    COMMA           reduce using rule 90 (cte -> ID .)
    DO              reduce using rule 90 (cte -> ID .)


state 84

    (59) main -> MAIN LBRACE statutes_aux RBRACE .

    $end            reduce using rule 59 (main -> MAIN LBRACE statutes_aux RBRACE .)


state 85

    (60) main -> MAIN LBRACE dec_vars statutes_aux . RBRACE

    RBRACE          shift and go to state 114


state 86

    (67) call -> ID . LPAREN call_aux RPAREN
    (68) call -> ID . POINT ID LPAREN call_aux RPAREN
    (76) vars -> ID .
    (77) vars -> ID . vars_aux
    (78) vars_aux -> . LBRACKET exp RBRACKET
    (79) vars_aux -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    LPAREN          shift and go to state 90
    POINT           shift and go to state 91
    EQUAL           reduce using rule 76 (vars -> ID .)
    LBRACKET        shift and go to state 93

    vars_aux                       shift and go to state 92

state 87

    (52) statutes_aux -> statutes statutes_aux .

    RBRACE          reduce using rule 52 (statutes_aux -> statutes statutes_aux .)
    RETURN          reduce using rule 52 (statutes_aux -> statutes statutes_aux .)


state 88

    (38) statutes -> call SEMICOLON .

    ID              reduce using rule 38 (statutes -> call SEMICOLON .)
    READ            reduce using rule 38 (statutes -> call SEMICOLON .)
    WRITE           reduce using rule 38 (statutes -> call SEMICOLON .)
    IF              reduce using rule 38 (statutes -> call SEMICOLON .)
    WHILE           reduce using rule 38 (statutes -> call SEMICOLON .)
    FROM            reduce using rule 38 (statutes -> call SEMICOLON .)
    RBRACE          reduce using rule 38 (statutes -> call SEMICOLON .)
    RETURN          reduce using rule 38 (statutes -> call SEMICOLON .)


state 89

    (44) assignation -> vars EQUAL . expression SEMICOLON
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 115
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 90

    (67) call -> ID LPAREN . call_aux RPAREN
    (69) call_aux -> . call_aux_2
    (70) call_aux -> . empty
    (71) call_aux_2 -> . exp
    (72) call_aux_2 -> . exp COMMA call_aux_2
    (95) empty -> .
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    RPAREN          reduce using rule 95 (empty -> .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    call_aux                       shift and go to state 116
    call_aux_2                     shift and go to state 117
    empty                          shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 91

    (68) call -> ID POINT . ID LPAREN call_aux RPAREN

    ID              shift and go to state 120


state 92

    (77) vars -> ID vars_aux .

    EQUAL           reduce using rule 77 (vars -> ID vars_aux .)
    COMMA           reduce using rule 77 (vars -> ID vars_aux .)
    RPAREN          reduce using rule 77 (vars -> ID vars_aux .)


state 93

    (78) vars_aux -> LBRACKET . exp RBRACKET
    (79) vars_aux -> LBRACKET . exp RBRACKET LBRACKET exp RBRACKET
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    exp                            shift and go to state 121
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 94

    (73) read -> READ LPAREN . read_aux RPAREN SEMICOLON
    (74) read_aux -> . vars
    (75) read_aux -> . vars COMMA read_aux
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 100

    read_aux                       shift and go to state 122
    vars                           shift and go to state 123

state 95

    (45) write -> WRITE LPAREN . write_aux RPAREN SEMICOLON
    (46) write_aux -> . expression
    (47) write_aux -> . expression COMMA write_aux
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    write_aux                      shift and go to state 124
    expression                     shift and go to state 125
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 96

    (48) condition -> IF condition_aux .

    ID              reduce using rule 48 (condition -> IF condition_aux .)
    READ            reduce using rule 48 (condition -> IF condition_aux .)
    WRITE           reduce using rule 48 (condition -> IF condition_aux .)
    IF              reduce using rule 48 (condition -> IF condition_aux .)
    WHILE           reduce using rule 48 (condition -> IF condition_aux .)
    FROM            reduce using rule 48 (condition -> IF condition_aux .)
    RBRACE          reduce using rule 48 (condition -> IF condition_aux .)
    RETURN          reduce using rule 48 (condition -> IF condition_aux .)


state 97

    (49) condition_aux -> LPAREN . expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> LPAREN . expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 126
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 98

    (55) while -> WHILE LPAREN . expression RPAREN DO LBRACE statutes_aux RBRACE
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 127
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 99

    (56) for -> FROM assignation . UNTIL expression DO LBRACE statutes_aux RBRACE

    UNTIL           shift and go to state 128


state 100

    (76) vars -> ID .
    (77) vars -> ID . vars_aux
    (78) vars_aux -> . LBRACKET exp RBRACKET
    (79) vars_aux -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    EQUAL           reduce using rule 76 (vars -> ID .)
    COMMA           reduce using rule 76 (vars -> ID .)
    RPAREN          reduce using rule 76 (vars -> ID .)
    LBRACKET        shift and go to state 93

    vars_aux                       shift and go to state 92

state 101

    (16) functions -> functType ID LPAREN . RPAREN LBRACE functBody return RBRACE
    (17) functions -> functType ID LPAREN . params RPAREN LBRACE functBody return RBRACE
    (18) functions -> functType ID LPAREN . RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> functType ID LPAREN . params RPAREN LBRACE functBody return RBRACE functions
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    RPAREN          shift and go to state 129
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    params                         shift and go to state 130
    type                           shift and go to state 131
    type_aux                       shift and go to state 32

state 102

    (25) type -> type_aux LBRACKET RBRACKET .
    (26) type -> type_aux LBRACKET RBRACKET . LBRACKET RBRACKET

    ID              reduce using rule 25 (type -> type_aux LBRACKET RBRACKET .)
    LBRACKET        shift and go to state 132


state 103

    (57) class -> CLASS ID LBRACE dec_vars . functions RBRACE
    (16) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions
    (20) functType -> . VOID
    (21) functType -> . type
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    VOID            shift and go to state 30
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    functions                      shift and go to state 133
    functType                      shift and go to state 29
    type                           shift and go to state 31
    type_aux                       shift and go to state 32

state 104

    (58) class -> CLASS ID INHERITS ID . LBRACE dec_vars functions RBRACE

    LBRACE          shift and go to state 134


state 105

    (13) type_vars -> type_aux LBRACKET exp RBRACKET LBRACKET . exp RBRACKET
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    exp                            shift and go to state 135
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 106

    (81) exp -> term PLUS exp .

    RBRACKET        reduce using rule 81 (exp -> term PLUS exp .)
    RELOP           reduce using rule 81 (exp -> term PLUS exp .)
    AND             reduce using rule 81 (exp -> term PLUS exp .)
    OR              reduce using rule 81 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 81 (exp -> term PLUS exp .)
    SEMICOLON       reduce using rule 81 (exp -> term PLUS exp .)
    COMMA           reduce using rule 81 (exp -> term PLUS exp .)
    DO              reduce using rule 81 (exp -> term PLUS exp .)


state 107

    (82) exp -> term MINUS exp .

    RBRACKET        reduce using rule 82 (exp -> term MINUS exp .)
    RELOP           reduce using rule 82 (exp -> term MINUS exp .)
    AND             reduce using rule 82 (exp -> term MINUS exp .)
    OR              reduce using rule 82 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 82 (exp -> term MINUS exp .)
    SEMICOLON       reduce using rule 82 (exp -> term MINUS exp .)
    COMMA           reduce using rule 82 (exp -> term MINUS exp .)
    DO              reduce using rule 82 (exp -> term MINUS exp .)


state 108

    (84) term -> factor TIMES term .

    PLUS            reduce using rule 84 (term -> factor TIMES term .)
    MINUS           reduce using rule 84 (term -> factor TIMES term .)
    RBRACKET        reduce using rule 84 (term -> factor TIMES term .)
    RELOP           reduce using rule 84 (term -> factor TIMES term .)
    AND             reduce using rule 84 (term -> factor TIMES term .)
    OR              reduce using rule 84 (term -> factor TIMES term .)
    RPAREN          reduce using rule 84 (term -> factor TIMES term .)
    SEMICOLON       reduce using rule 84 (term -> factor TIMES term .)
    COMMA           reduce using rule 84 (term -> factor TIMES term .)
    DO              reduce using rule 84 (term -> factor TIMES term .)


state 109

    (85) term -> factor DIVIDE term .

    PLUS            reduce using rule 85 (term -> factor DIVIDE term .)
    MINUS           reduce using rule 85 (term -> factor DIVIDE term .)
    RBRACKET        reduce using rule 85 (term -> factor DIVIDE term .)
    RELOP           reduce using rule 85 (term -> factor DIVIDE term .)
    AND             reduce using rule 85 (term -> factor DIVIDE term .)
    OR              reduce using rule 85 (term -> factor DIVIDE term .)
    RPAREN          reduce using rule 85 (term -> factor DIVIDE term .)
    SEMICOLON       reduce using rule 85 (term -> factor DIVIDE term .)
    COMMA           reduce using rule 85 (term -> factor DIVIDE term .)
    DO              reduce using rule 85 (term -> factor DIVIDE term .)


state 110

    (89) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RELOP           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 89 (factor -> LPAREN expression RPAREN .)


state 111

    (62) expression -> expression_aux RELOP . expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression_aux                 shift and go to state 136
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 112

    (63) expression -> expression_aux AND . expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression_aux                 shift and go to state 137
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 113

    (64) expression -> expression_aux OR . expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression_aux                 shift and go to state 138
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 114

    (60) main -> MAIN LBRACE dec_vars statutes_aux RBRACE .

    $end            reduce using rule 60 (main -> MAIN LBRACE dec_vars statutes_aux RBRACE .)


state 115

    (44) assignation -> vars EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 139


state 116

    (67) call -> ID LPAREN call_aux . RPAREN

    RPAREN          shift and go to state 140


state 117

    (69) call_aux -> call_aux_2 .

    RPAREN          reduce using rule 69 (call_aux -> call_aux_2 .)


state 118

    (70) call_aux -> empty .

    RPAREN          reduce using rule 70 (call_aux -> empty .)


state 119

    (71) call_aux_2 -> exp .
    (72) call_aux_2 -> exp . COMMA call_aux_2

    RPAREN          reduce using rule 71 (call_aux_2 -> exp .)
    COMMA           shift and go to state 141


state 120

    (68) call -> ID POINT ID . LPAREN call_aux RPAREN

    LPAREN          shift and go to state 142


state 121

    (78) vars_aux -> LBRACKET exp . RBRACKET
    (79) vars_aux -> LBRACKET exp . RBRACKET LBRACKET exp RBRACKET

    RBRACKET        shift and go to state 143


state 122

    (73) read -> READ LPAREN read_aux . RPAREN SEMICOLON

    RPAREN          shift and go to state 144


state 123

    (74) read_aux -> vars .
    (75) read_aux -> vars . COMMA read_aux

    RPAREN          reduce using rule 74 (read_aux -> vars .)
    COMMA           shift and go to state 145


state 124

    (45) write -> WRITE LPAREN write_aux . RPAREN SEMICOLON

    RPAREN          shift and go to state 146


state 125

    (46) write_aux -> expression .
    (47) write_aux -> expression . COMMA write_aux

    RPAREN          reduce using rule 46 (write_aux -> expression .)
    COMMA           shift and go to state 147


state 126

    (49) condition_aux -> LPAREN expression . RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> LPAREN expression . RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE

    RPAREN          shift and go to state 148


state 127

    (55) while -> WHILE LPAREN expression . RPAREN DO LBRACE statutes_aux RBRACE

    RPAREN          shift and go to state 149


state 128

    (56) for -> FROM assignation UNTIL . expression DO LBRACE statutes_aux RBRACE
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 150
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 129

    (16) functions -> functType ID LPAREN RPAREN . LBRACE functBody return RBRACE
    (18) functions -> functType ID LPAREN RPAREN . LBRACE functBody return RBRACE functions

    LBRACE          shift and go to state 151


state 130

    (17) functions -> functType ID LPAREN params . RPAREN LBRACE functBody return RBRACE
    (19) functions -> functType ID LPAREN params . RPAREN LBRACE functBody return RBRACE functions

    RPAREN          shift and go to state 152


state 131

    (22) params -> type . ID
    (23) params -> type . ID COMMA params

    ID              shift and go to state 153


state 132

    (26) type -> type_aux LBRACKET RBRACKET LBRACKET . RBRACKET

    RBRACKET        shift and go to state 154


state 133

    (57) class -> CLASS ID LBRACE dec_vars functions . RBRACE

    RBRACE          shift and go to state 155


state 134

    (58) class -> CLASS ID INHERITS ID LBRACE . dec_vars functions RBRACE
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    VOID            reduce using rule 95 (empty -> .)
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! CHAR            [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! BOOL            [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]

    dec_vars                       shift and go to state 156
    type_vars                      shift and go to state 8
    empty                          shift and go to state 9
    type_aux                       shift and go to state 10

state 135

    (13) type_vars -> type_aux LBRACKET exp RBRACKET LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 157


state 136

    (62) expression -> expression_aux RELOP expression_aux .

    RPAREN          reduce using rule 62 (expression -> expression_aux RELOP expression_aux .)
    SEMICOLON       reduce using rule 62 (expression -> expression_aux RELOP expression_aux .)
    COMMA           reduce using rule 62 (expression -> expression_aux RELOP expression_aux .)
    DO              reduce using rule 62 (expression -> expression_aux RELOP expression_aux .)


state 137

    (63) expression -> expression_aux AND expression_aux .

    RPAREN          reduce using rule 63 (expression -> expression_aux AND expression_aux .)
    SEMICOLON       reduce using rule 63 (expression -> expression_aux AND expression_aux .)
    COMMA           reduce using rule 63 (expression -> expression_aux AND expression_aux .)
    DO              reduce using rule 63 (expression -> expression_aux AND expression_aux .)


state 138

    (64) expression -> expression_aux OR expression_aux .

    RPAREN          reduce using rule 64 (expression -> expression_aux OR expression_aux .)
    SEMICOLON       reduce using rule 64 (expression -> expression_aux OR expression_aux .)
    COMMA           reduce using rule 64 (expression -> expression_aux OR expression_aux .)
    DO              reduce using rule 64 (expression -> expression_aux OR expression_aux .)


state 139

    (44) assignation -> vars EQUAL expression SEMICOLON .

    ID              reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    READ            reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    WRITE           reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    IF              reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    FROM            reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)
    UNTIL           reduce using rule 44 (assignation -> vars EQUAL expression SEMICOLON .)


state 140

    (67) call -> ID LPAREN call_aux RPAREN .

    SEMICOLON       reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)
    RELOP           reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)
    AND             reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)
    OR              reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)
    RPAREN          reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)
    COMMA           reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)
    DO              reduce using rule 67 (call -> ID LPAREN call_aux RPAREN .)


state 141

    (72) call_aux_2 -> exp COMMA . call_aux_2
    (71) call_aux_2 -> . exp
    (72) call_aux_2 -> . exp COMMA call_aux_2
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    exp                            shift and go to state 119
    call_aux_2                     shift and go to state 158
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 142

    (68) call -> ID POINT ID LPAREN . call_aux RPAREN
    (69) call_aux -> . call_aux_2
    (70) call_aux -> . empty
    (71) call_aux_2 -> . exp
    (72) call_aux_2 -> . exp COMMA call_aux_2
    (95) empty -> .
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    RPAREN          reduce using rule 95 (empty -> .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    call_aux                       shift and go to state 159
    call_aux_2                     shift and go to state 117
    empty                          shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 143

    (78) vars_aux -> LBRACKET exp RBRACKET .
    (79) vars_aux -> LBRACKET exp RBRACKET . LBRACKET exp RBRACKET

    EQUAL           reduce using rule 78 (vars_aux -> LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 78 (vars_aux -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 78 (vars_aux -> LBRACKET exp RBRACKET .)
    LBRACKET        shift and go to state 160


state 144

    (73) read -> READ LPAREN read_aux RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 161


state 145

    (75) read_aux -> vars COMMA . read_aux
    (74) read_aux -> . vars
    (75) read_aux -> . vars COMMA read_aux
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 100

    vars                           shift and go to state 123
    read_aux                       shift and go to state 162

state 146

    (45) write -> WRITE LPAREN write_aux RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 163


state 147

    (47) write_aux -> expression COMMA . write_aux
    (46) write_aux -> . expression
    (47) write_aux -> . expression COMMA write_aux
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 125
    write_aux                      shift and go to state 164
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 148

    (49) condition_aux -> LPAREN expression RPAREN . THEN LBRACE statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> LPAREN expression RPAREN . THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE

    THEN            shift and go to state 165


state 149

    (55) while -> WHILE LPAREN expression RPAREN . DO LBRACE statutes_aux RBRACE

    DO              shift and go to state 166


state 150

    (56) for -> FROM assignation UNTIL expression . DO LBRACE statutes_aux RBRACE

    DO              shift and go to state 167


state 151

    (16) functions -> functType ID LPAREN RPAREN LBRACE . functBody return RBRACE
    (18) functions -> functType ID LPAREN RPAREN LBRACE . functBody return RBRACE functions
    (33) functBody -> . statutes_aux
    (34) functBody -> . dec_vars statutes_aux
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FROM resolved as shift
    ID              shift and go to state 60
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15

  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! READ            [ reduce using rule 95 (empty -> .) ]
  ! WRITE           [ reduce using rule 95 (empty -> .) ]
  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FROM            [ reduce using rule 95 (empty -> .) ]

    functBody                      shift and go to state 168
    statutes_aux                   shift and go to state 169
    dec_vars                       shift and go to state 170
    statutes                       shift and go to state 51
    type_vars                      shift and go to state 8
    empty                          shift and go to state 9
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    type_aux                       shift and go to state 10
    vars                           shift and go to state 59

state 152

    (17) functions -> functType ID LPAREN params RPAREN . LBRACE functBody return RBRACE
    (19) functions -> functType ID LPAREN params RPAREN . LBRACE functBody return RBRACE functions

    LBRACE          shift and go to state 171


state 153

    (22) params -> type ID .
    (23) params -> type ID . COMMA params

    RPAREN          reduce using rule 22 (params -> type ID .)
    COMMA           shift and go to state 172


state 154

    (26) type -> type_aux LBRACKET RBRACKET LBRACKET RBRACKET .

    ID              reduce using rule 26 (type -> type_aux LBRACKET RBRACKET LBRACKET RBRACKET .)


state 155

    (57) class -> CLASS ID LBRACE dec_vars functions RBRACE .

    CLASS           reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    VOID            reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    INT             reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    FLOAT           reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    CHAR            reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    STRING          reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    BOOL            reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    ID              reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)
    MAIN            reduce using rule 57 (class -> CLASS ID LBRACE dec_vars functions RBRACE .)


state 156

    (58) class -> CLASS ID INHERITS ID LBRACE dec_vars . functions RBRACE
    (16) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions
    (20) functType -> . VOID
    (21) functType -> . type
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    VOID            shift and go to state 30
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    functions                      shift and go to state 173
    functType                      shift and go to state 29
    type                           shift and go to state 31
    type_aux                       shift and go to state 32

state 157

    (13) type_vars -> type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET .

    ID              reduce using rule 13 (type_vars -> type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)


state 158

    (72) call_aux_2 -> exp COMMA call_aux_2 .

    RPAREN          reduce using rule 72 (call_aux_2 -> exp COMMA call_aux_2 .)


state 159

    (68) call -> ID POINT ID LPAREN call_aux . RPAREN

    RPAREN          shift and go to state 174


state 160

    (79) vars_aux -> LBRACKET exp RBRACKET LBRACKET . exp RBRACKET
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    ID              shift and go to state 44
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    exp                            shift and go to state 175
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 161

    (73) read -> READ LPAREN read_aux RPAREN SEMICOLON .

    ID              reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    READ            reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    WRITE           reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    IF              reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    WHILE           reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    FROM            reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    RBRACE          reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)
    RETURN          reduce using rule 73 (read -> READ LPAREN read_aux RPAREN SEMICOLON .)


state 162

    (75) read_aux -> vars COMMA read_aux .

    RPAREN          reduce using rule 75 (read_aux -> vars COMMA read_aux .)


state 163

    (45) write -> WRITE LPAREN write_aux RPAREN SEMICOLON .

    ID              reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    READ            reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    WRITE           reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    IF              reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    FROM            reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    RBRACE          reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)
    RETURN          reduce using rule 45 (write -> WRITE LPAREN write_aux RPAREN SEMICOLON .)


state 164

    (47) write_aux -> expression COMMA write_aux .

    RPAREN          reduce using rule 47 (write_aux -> expression COMMA write_aux .)


state 165

    (49) condition_aux -> LPAREN expression RPAREN THEN . LBRACE statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> LPAREN expression RPAREN THEN . LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE

    LBRACE          shift and go to state 176


state 166

    (55) while -> WHILE LPAREN expression RPAREN DO . LBRACE statutes_aux RBRACE

    LBRACE          shift and go to state 177


state 167

    (56) for -> FROM assignation UNTIL expression DO . LBRACE statutes_aux RBRACE

    LBRACE          shift and go to state 178


state 168

    (16) functions -> functType ID LPAREN RPAREN LBRACE functBody . return RBRACE
    (18) functions -> functType ID LPAREN RPAREN LBRACE functBody . return RBRACE functions
    (35) return -> . RETURN expression SEMICOLON
    (36) return -> . empty
    (95) empty -> .

    RETURN          shift and go to state 180
    RBRACE          reduce using rule 95 (empty -> .)

    return                         shift and go to state 179
    empty                          shift and go to state 181

state 169

    (33) functBody -> statutes_aux .

    RETURN          reduce using rule 33 (functBody -> statutes_aux .)
    RBRACE          reduce using rule 33 (functBody -> statutes_aux .)


state 170

    (34) functBody -> dec_vars . statutes_aux
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statutes_aux                   shift and go to state 182
    statutes                       shift and go to state 51
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 171

    (17) functions -> functType ID LPAREN params RPAREN LBRACE . functBody return RBRACE
    (19) functions -> functType ID LPAREN params RPAREN LBRACE . functBody return RBRACE functions
    (33) functBody -> . statutes_aux
    (34) functBody -> . dec_vars statutes_aux
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (8) dec_vars -> . type_vars dec_vars_aux SEMICOLON
    (9) dec_vars -> . type_vars dec_vars_aux SEMICOLON dec_vars
    (10) dec_vars -> . empty
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (11) type_vars -> . type_aux
    (12) type_vars -> . type_aux LBRACKET exp RBRACKET
    (13) type_vars -> . type_aux LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (95) empty -> .
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FROM resolved as shift
    ID              shift and go to state 60
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15

  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! READ            [ reduce using rule 95 (empty -> .) ]
  ! WRITE           [ reduce using rule 95 (empty -> .) ]
  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FROM            [ reduce using rule 95 (empty -> .) ]

    functBody                      shift and go to state 183
    statutes_aux                   shift and go to state 169
    dec_vars                       shift and go to state 170
    statutes                       shift and go to state 51
    type_vars                      shift and go to state 8
    empty                          shift and go to state 9
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    type_aux                       shift and go to state 10
    vars                           shift and go to state 59

state 172

    (23) params -> type ID COMMA . params
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    type                           shift and go to state 131
    params                         shift and go to state 184
    type_aux                       shift and go to state 32

state 173

    (58) class -> CLASS ID INHERITS ID LBRACE dec_vars functions . RBRACE

    RBRACE          shift and go to state 185


state 174

    (68) call -> ID POINT ID LPAREN call_aux RPAREN .

    SEMICOLON       reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)
    RELOP           reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)
    AND             reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)
    OR              reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)
    RPAREN          reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)
    COMMA           reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)
    DO              reduce using rule 68 (call -> ID POINT ID LPAREN call_aux RPAREN .)


state 175

    (79) vars_aux -> LBRACKET exp RBRACKET LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 186


state 176

    (49) condition_aux -> LPAREN expression RPAREN THEN LBRACE . statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE . statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statutes_aux                   shift and go to state 187
    statutes                       shift and go to state 51
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 177

    (55) while -> WHILE LPAREN expression RPAREN DO LBRACE . statutes_aux RBRACE
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statutes_aux                   shift and go to state 188
    statutes                       shift and go to state 51
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 178

    (56) for -> FROM assignation UNTIL expression DO LBRACE . statutes_aux RBRACE
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    assignation                    shift and go to state 52
    statutes_aux                   shift and go to state 189
    statutes                       shift and go to state 51
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 179

    (16) functions -> functType ID LPAREN RPAREN LBRACE functBody return . RBRACE
    (18) functions -> functType ID LPAREN RPAREN LBRACE functBody return . RBRACE functions

    RBRACE          shift and go to state 190


state 180

    (35) return -> RETURN . expression SEMICOLON
    (61) expression -> . expression_aux
    (62) expression -> . expression_aux RELOP expression_aux
    (63) expression -> . expression_aux AND expression_aux
    (64) expression -> . expression_aux OR expression_aux
    (65) expression_aux -> . call
    (66) expression_aux -> . exp
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (80) exp -> . term
    (81) exp -> . term PLUS exp
    (82) exp -> . term MINUS exp
    (83) term -> . factor
    (84) term -> . factor TIMES term
    (85) term -> . factor DIVIDE term
    (86) factor -> . PLUS cte
    (87) factor -> . MINUS cte
    (88) factor -> . cte
    (89) factor -> . LPAREN expression RPAREN
    (90) cte -> . ID
    (91) cte -> . CTEI
    (92) cte -> . CTEF
    (93) cte -> . CTESTRING
    (94) cte -> . CTECHAR

    ID              shift and go to state 83
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LPAREN          shift and go to state 43
    CTEI            shift and go to state 45
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 47
    CTECHAR         shift and go to state 48

    expression                     shift and go to state 191
    expression_aux                 shift and go to state 80
    call                           shift and go to state 81
    exp                            shift and go to state 82
    term                           shift and go to state 38
    factor                         shift and go to state 41
    cte                            shift and go to state 42

state 181

    (36) return -> empty .

    RBRACE          reduce using rule 36 (return -> empty .)


state 182

    (34) functBody -> dec_vars statutes_aux .

    RETURN          reduce using rule 34 (functBody -> dec_vars statutes_aux .)
    RBRACE          reduce using rule 34 (functBody -> dec_vars statutes_aux .)


state 183

    (17) functions -> functType ID LPAREN params RPAREN LBRACE functBody . return RBRACE
    (19) functions -> functType ID LPAREN params RPAREN LBRACE functBody . return RBRACE functions
    (35) return -> . RETURN expression SEMICOLON
    (36) return -> . empty
    (95) empty -> .

    RETURN          shift and go to state 180
    RBRACE          reduce using rule 95 (empty -> .)

    return                         shift and go to state 192
    empty                          shift and go to state 181

state 184

    (23) params -> type ID COMMA params .

    RPAREN          reduce using rule 23 (params -> type ID COMMA params .)


state 185

    (58) class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .

    CLASS           reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    VOID            reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    INT             reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    FLOAT           reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    CHAR            reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    STRING          reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    BOOL            reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    ID              reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)
    MAIN            reduce using rule 58 (class -> CLASS ID INHERITS ID LBRACE dec_vars functions RBRACE .)


state 186

    (79) vars_aux -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .

    EQUAL           reduce using rule 79 (vars_aux -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 79 (vars_aux -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 79 (vars_aux -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)


state 187

    (49) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux . RBRACE condition_aux_2
    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux . RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE

    RBRACE          shift and go to state 193


state 188

    (55) while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux . RBRACE

    RBRACE          shift and go to state 194


state 189

    (56) for -> FROM assignation UNTIL expression DO LBRACE statutes_aux . RBRACE

    RBRACE          shift and go to state 195


state 190

    (16) functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE .
    (18) functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE . functions
    (16) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions
    (20) functType -> . VOID
    (21) functType -> . type
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    MAIN            reduce using rule 16 (functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE .)
    RBRACE          reduce using rule 16 (functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE .)
    VOID            shift and go to state 30
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    functType                      shift and go to state 29
    functions                      shift and go to state 196
    type                           shift and go to state 31
    type_aux                       shift and go to state 32

state 191

    (35) return -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 197


state 192

    (17) functions -> functType ID LPAREN params RPAREN LBRACE functBody return . RBRACE
    (19) functions -> functType ID LPAREN params RPAREN LBRACE functBody return . RBRACE functions

    RBRACE          shift and go to state 198


state 193

    (49) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE . condition_aux_2
    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE . condition_aux_2 ELSE LBRACE statutes_aux RBRACE
    (53) condition_aux_2 -> . ELIF condition_aux
    (54) condition_aux_2 -> . empty
    (95) empty -> .

    ELIF            shift and go to state 200
    ELSE            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    READ            reduce using rule 95 (empty -> .)
    WRITE           reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    FROM            reduce using rule 95 (empty -> .)
    RBRACE          reduce using rule 95 (empty -> .)
    RETURN          reduce using rule 95 (empty -> .)

    condition_aux_2                shift and go to state 199
    empty                          shift and go to state 201

state 194

    (55) while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .

    ID              reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    READ            reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    WRITE           reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    IF              reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    WHILE           reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    FROM            reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    RBRACE          reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)
    RETURN          reduce using rule 55 (while -> WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE .)


state 195

    (56) for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .

    ID              reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    READ            reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    WRITE           reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    IF              reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    WHILE           reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    FROM            reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    RBRACE          reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)
    RETURN          reduce using rule 56 (for -> FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE .)


state 196

    (18) functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions .

    MAIN            reduce using rule 18 (functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions .)
    RBRACE          reduce using rule 18 (functions -> functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions .)


state 197

    (35) return -> RETURN expression SEMICOLON .

    RBRACE          reduce using rule 35 (return -> RETURN expression SEMICOLON .)


state 198

    (17) functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE .
    (19) functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE . functions
    (16) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE
    (17) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE
    (18) functions -> . functType ID LPAREN RPAREN LBRACE functBody return RBRACE functions
    (19) functions -> . functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions
    (20) functType -> . VOID
    (21) functType -> . type
    (24) type -> . type_aux
    (25) type -> . type_aux LBRACKET RBRACKET
    (26) type -> . type_aux LBRACKET RBRACKET LBRACKET RBRACKET
    (27) type_aux -> . INT
    (28) type_aux -> . FLOAT
    (29) type_aux -> . CHAR
    (30) type_aux -> . STRING
    (31) type_aux -> . BOOL
    (32) type_aux -> . ID

    MAIN            reduce using rule 17 (functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE .)
    RBRACE          reduce using rule 17 (functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE .)
    VOID            shift and go to state 30
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    CHAR            shift and go to state 13
    STRING          shift and go to state 14
    BOOL            shift and go to state 15
    ID              shift and go to state 5

    functType                      shift and go to state 29
    functions                      shift and go to state 202
    type                           shift and go to state 31
    type_aux                       shift and go to state 32

state 199

    (49) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .
    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 . ELSE LBRACE statutes_aux RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    READ            reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    WRITE           reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    IF              reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    WHILE           reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    FROM            reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    RBRACE          reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    RETURN          reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .)
    ELSE            shift and go to state 203

  ! ELSE            [ reduce using rule 49 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 .) ]


state 200

    (53) condition_aux_2 -> ELIF . condition_aux
    (49) condition_aux -> . LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2
    (50) condition_aux -> . LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE

    LPAREN          shift and go to state 97

    condition_aux                  shift and go to state 204

state 201

    (54) condition_aux_2 -> empty .

    ELSE            reduce using rule 54 (condition_aux_2 -> empty .)
    ID              reduce using rule 54 (condition_aux_2 -> empty .)
    READ            reduce using rule 54 (condition_aux_2 -> empty .)
    WRITE           reduce using rule 54 (condition_aux_2 -> empty .)
    IF              reduce using rule 54 (condition_aux_2 -> empty .)
    WHILE           reduce using rule 54 (condition_aux_2 -> empty .)
    FROM            reduce using rule 54 (condition_aux_2 -> empty .)
    RBRACE          reduce using rule 54 (condition_aux_2 -> empty .)
    RETURN          reduce using rule 54 (condition_aux_2 -> empty .)


state 202

    (19) functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions .

    MAIN            reduce using rule 19 (functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions .)
    RBRACE          reduce using rule 19 (functions -> functType ID LPAREN params RPAREN LBRACE functBody return RBRACE functions .)


state 203

    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE . LBRACE statutes_aux RBRACE

    LBRACE          shift and go to state 205


state 204

    (53) condition_aux_2 -> ELIF condition_aux .

    ELSE            reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    ID              reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    READ            reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    WRITE           reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    IF              reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    WHILE           reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    FROM            reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    RBRACE          reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)
    RETURN          reduce using rule 53 (condition_aux_2 -> ELIF condition_aux .)


state 205

    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE . statutes_aux RBRACE
    (51) statutes_aux -> . statutes
    (52) statutes_aux -> . statutes statutes_aux
    (37) statutes -> . assignation
    (38) statutes -> . call SEMICOLON
    (39) statutes -> . read
    (40) statutes -> . write
    (41) statutes -> . condition
    (42) statutes -> . while
    (43) statutes -> . for
    (44) assignation -> . vars EQUAL expression SEMICOLON
    (67) call -> . ID LPAREN call_aux RPAREN
    (68) call -> . ID POINT ID LPAREN call_aux RPAREN
    (73) read -> . READ LPAREN read_aux RPAREN SEMICOLON
    (45) write -> . WRITE LPAREN write_aux RPAREN SEMICOLON
    (48) condition -> . IF condition_aux
    (55) while -> . WHILE LPAREN expression RPAREN DO LBRACE statutes_aux RBRACE
    (56) for -> . FROM assignation UNTIL expression DO LBRACE statutes_aux RBRACE
    (76) vars -> . ID
    (77) vars -> . ID vars_aux

    ID              shift and go to state 86
    READ            shift and go to state 61
    WRITE           shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statutes_aux                   shift and go to state 206
    statutes                       shift and go to state 51
    assignation                    shift and go to state 52
    call                           shift and go to state 53
    read                           shift and go to state 54
    write                          shift and go to state 55
    condition                      shift and go to state 56
    while                          shift and go to state 57
    for                            shift and go to state 58
    vars                           shift and go to state 59

state 206

    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux . RBRACE

    RBRACE          shift and go to state 207


state 207

    (50) condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .

    ID              reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    READ            reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    WRITE           reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    IF              reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    WHILE           reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    FROM            reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    RBRACE          reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    RETURN          reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)
    ELSE            reduce using rule 50 (condition_aux -> LPAREN expression RPAREN THEN LBRACE statutes_aux RBRACE condition_aux_2 ELSE LBRACE statutes_aux RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: shift/reduce conflict for READ in state 25 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 25 resolved as shift
WARNING: shift/reduce conflict for IF in state 25 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 25 resolved as shift
WARNING: shift/reduce conflict for FROM in state 25 resolved as shift
WARNING: shift/reduce conflict for INT in state 35 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 35 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 35 resolved as shift
WARNING: shift/reduce conflict for STRING in state 35 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 35 resolved as shift
WARNING: shift/reduce conflict for ID in state 35 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 60 resolved as shift
WARNING: shift/reduce conflict for INT in state 68 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 68 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 68 resolved as shift
WARNING: shift/reduce conflict for STRING in state 68 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 68 resolved as shift
WARNING: shift/reduce conflict for ID in state 68 resolved as shift
WARNING: shift/reduce conflict for INT in state 134 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 134 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 134 resolved as shift
WARNING: shift/reduce conflict for STRING in state 134 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 134 resolved as shift
WARNING: shift/reduce conflict for ID in state 134 resolved as shift
WARNING: shift/reduce conflict for ID in state 151 resolved as shift
WARNING: shift/reduce conflict for READ in state 151 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 151 resolved as shift
WARNING: shift/reduce conflict for IF in state 151 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 151 resolved as shift
WARNING: shift/reduce conflict for FROM in state 151 resolved as shift
WARNING: shift/reduce conflict for ID in state 171 resolved as shift
WARNING: shift/reduce conflict for READ in state 171 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 171 resolved as shift
WARNING: shift/reduce conflict for IF in state 171 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 171 resolved as shift
WARNING: shift/reduce conflict for FROM in state 171 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 199 resolved as shift
WARNING: reduce/reduce conflict in state 19 resolved using rule (class_aux -> class)
WARNING: rejected rule (empty -> <empty>) in state 19
WARNING: reduce/reduce conflict in state 35 resolved using rule (dec_vars -> type_vars dec_vars_aux SEMICOLON)
WARNING: rejected rule (empty -> <empty>) in state 35
